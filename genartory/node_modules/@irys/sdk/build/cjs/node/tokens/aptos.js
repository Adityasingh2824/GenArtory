"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const arbundles_1 = require("arbundles");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const base_1 = require("./base");
const js_sha3_1 = tslib_1.__importDefault(require("js-sha3"));
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
class AptosConfig extends base_1.BaseNodeToken {
    constructor(config) {
        var _a, _b, _c;
        if (typeof config.wallet === "string" && config.wallet.length === 66) {
            // If signingFunction is provided, the given `wallet` is a public key
            if ((_a = config === null || config === void 0 ? void 0 : config.opts) === null || _a === void 0 ? void 0 : _a.signingFunction) {
                config.wallet = Buffer.from(config.wallet.slice(2), "hex");
            }
            else {
                config.wallet = new ts_sdk_1.Ed25519PrivateKey(config.wallet);
                // @ts-expect-error custom prop
                config.accountInstance = ts_sdk_1.Account.fromPrivateKey({ privateKey: config === null || config === void 0 ? void 0 : config.wallet });
            }
        }
        super(config);
        this.txLock = Promise.resolve();
        this.locked = false;
        // @ts-expect-error assignment doesn't carry through for some reason
        this.accountInstance = config.accountInstance;
        this.signingFn = (_b = config === null || config === void 0 ? void 0 : config.opts) === null || _b === void 0 ? void 0 : _b.signingFunction;
        this.needsFee = true;
        this.base = ["octa", 1e8];
        // In the Aptos context, this.providerUrl is the Aptos Network enum type we want
        // to work with. read more https://github.com/aptos-labs/aptos-ts-sdk/blob/main/src/api/aptosConfig.ts#L14
        // this.providerUrl is a Network enum type represents the current configured network
        this.aptosConfig = new ts_sdk_1.AptosConfig(Object.assign({ network: this.providerUrl }, (_c = config === null || config === void 0 ? void 0 : config.opts) === null || _c === void 0 ? void 0 : _c.aptosSdkConfig));
    }
    getProvider() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return ((_a = this.providerInstance) !== null && _a !== void 0 ? _a : (this.providerInstance = new ts_sdk_1.Aptos(this.aptosConfig)));
        });
    }
    getTx(txId) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            const tx = (yield client.waitForTransaction({ transactionHash: txId }));
            const payload = tx === null || tx === void 0 ? void 0 : tx.payload;
            if (!tx.success) {
                throw new Error((_a = tx === null || tx === void 0 ? void 0 : tx.vm_status) !== null && _a !== void 0 ? _a : "Unknown Aptos error");
            }
            if (!((payload === null || payload === void 0 ? void 0 : payload.function) === "0x1::coin::transfer" &&
                (payload === null || payload === void 0 ? void 0 : payload.type_arguments[0]) === "0x1::aptos_coin::AptosCoin" &&
                (tx === null || tx === void 0 ? void 0 : tx.vm_status) === "Executed successfully")) {
                throw new Error(`Aptos tx ${txId} failed validation`);
            }
            const isPending = tx.type === "pending_transaction";
            return {
                to: payload.arguments[0],
                from: tx.sender,
                amount: new bignumber_js_1.default(payload.arguments[1]),
                pending: isPending,
                confirmed: !isPending,
            };
        });
    }
    ownerToAddress(owner) {
        const hash = js_sha3_1.default.sha3_256.create();
        hash.update(Buffer.from(owner));
        hash.update("\x00");
        return `0x${hash.hex()}`;
    }
    sign(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getSigner().sign(data);
        });
    }
    getSigner() {
        if (this.signerInstance)
            return this.signerInstance;
        if (this.signingFn) {
            const signer = new arbundles_1.AptosSigner("", "0x" + this.getPublicKey().toString("hex"));
            signer.sign = this.signingFn; // override signer fn
            return (this.signerInstance = signer);
        }
        else {
            return (this.signerInstance = new arbundles_1.AptosSigner(this.accountInstance.privateKey.toString(), this.accountInstance.publicKey.toString()));
        }
    }
    verify(pub, data, signature) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield arbundles_1.AptosSigner.verify(pub, data, signature);
        });
    }
    getCurrentHeight() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new bignumber_js_1.default((yield (yield this.getProvider()).getLedgerInfo()).block_height);
        });
    }
    getFee(amount, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            const client = yield this.getProvider();
            const transaction = yield client.transaction.build.simple({
                sender: this.address,
                data: {
                    function: "0x1::coin::transfer",
                    typeArguments: ["0x1::aptos_coin::AptosCoin"],
                    functionArguments: [to !== null && to !== void 0 ? to : "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new bignumber_js_1.default(amount).toNumber()],
                },
            });
            const accountAuthenticator = new ts_sdk_1.AccountAuthenticatorEd25519(new ts_sdk_1.Ed25519PublicKey(this.getPublicKey()), new ts_sdk_1.Ed25519Signature(new Uint8Array(64)));
            const transactionAuthenticator = new ts_sdk_1.TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);
            const signedSimulation = new ts_sdk_1.SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();
            const queryParams = {
                estimate_gas_unit_price: true,
                estimate_max_gas_amount: true,
            };
            const [simulationResult] = yield (0, async_retry_1.default)((_) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { data } = yield (0, ts_sdk_1.postAptosFullNode)({
                    aptosConfig: this.aptosConfig,
                    body: signedSimulation,
                    path: "transactions/simulate",
                    params: queryParams,
                    originMethod: "simulateTransaction",
                    contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
                });
                if (!data[0].success || data[0].gas_used === "0")
                    throw new Error(`Tx simulation failed`);
                return data;
            }), { retries: 10 }).catch((_) => [{ gas_unit_price: "100", gas_used: "10" }]);
            return { gasUnitPrice: +simulationResult.gas_unit_price, maxGasAmount: Math.ceil(+simulationResult.gas_used * 2) };
            // const simulationResult = await client.simulateTransaction(this.accountInstance, rawTransaction, { estimateGasUnitPrice: true, estimateMaxGasAmount: true });
            // return new BigNumber(simulationResult?.[0].gas_unit_price).multipliedBy(simulationResult?.[0].gas_used);
            // const est = await provider.client.transactions.estimateGasPrice();
            // return new BigNumber(est.gas_estimate/* (await (await this.getProvider()).client.transactions.estimateGasPrice()).gas_estimate */); // * by gas limit (for upper limit)
        });
    }
    sendTx(data) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const { data: postData } = yield (0, ts_sdk_1.postAptosFullNode)({
                aptosConfig: this.aptosConfig,
                body: data.tx,
                path: "transactions",
                originMethod: "submitTransaction",
                contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
            });
            yield provider.waitForTransaction({ transactionHash: postData.hash });
            (_a = data.unlock) === null || _a === void 0 ? void 0 : _a.call(data);
            return postData.hash;
        });
    }
    createTx(amount, to, fee) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run irys.ready()");
            // mutex so multiple aptos txs aren't in flight with the same sequence number
            const unlock = yield this.lock();
            const client = yield this.getProvider();
            const transaction = yield client.transaction.build.simple({
                sender: this.address,
                data: {
                    function: "0x1::coin::transfer",
                    typeArguments: ["0x1::aptos_coin::AptosCoin"],
                    functionArguments: [to, new bignumber_js_1.default(amount).toNumber()],
                },
                options: {
                    gasUnitPrice: (_a = fee === null || fee === void 0 ? void 0 : fee.gasUnitPrice) !== null && _a !== void 0 ? _a : 100,
                    maxGasAmount: (_b = fee === null || fee === void 0 ? void 0 : fee.maxGasAmount) !== null && _b !== void 0 ? _b : 10,
                },
            });
            const message = (0, ts_sdk_1.generateSigningMessage)(transaction);
            const signerSignature = yield this.sign(message);
            const senderAuthenticator = new ts_sdk_1.AccountAuthenticatorEd25519(new ts_sdk_1.Ed25519PublicKey(this.getPublicKey()), new ts_sdk_1.Ed25519Signature(signerSignature));
            const signedTransaction = (0, ts_sdk_1.generateSignedTransaction)({ transaction, senderAuthenticator });
            return { txId: undefined, tx: { tx: signedTransaction, unlock } };
        });
    }
    getPublicKey() {
        var _a;
        if ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.signingFunction)
            return this.wallet;
        return Buffer.from(this.accountInstance.publicKey.toUint8Array());
    }
    ready() {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            this._address = yield client
                .lookupOriginalAccountAddress({ authenticationKey: (_a = this.address) !== null && _a !== void 0 ? _a : "" })
                .then((hs) => hs.toString())
                .catch((_) => this._address); // fallback to original
            if (((_b = this._address) === null || _b === void 0 ? void 0 : _b.length) == 66 && this._address.charAt(2) === "0") {
                this._address = this._address.slice(0, 2) + this._address.slice(3);
            }
        });
    }
    // basic async mutex for transaction creation - done so sequenceNumbers don't overlap
    lock() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.locked = true;
            let unlockNext;
            const willLock = new Promise((r) => (unlockNext = r));
            willLock.then(() => (this.locked = false));
            const willUnlock = this.txLock.then(() => unlockNext);
            this.txLock = this.txLock.then(() => willLock);
            return willUnlock;
        });
    }
}
exports.default = AptosConfig;
//# sourceMappingURL=aptos.js.map