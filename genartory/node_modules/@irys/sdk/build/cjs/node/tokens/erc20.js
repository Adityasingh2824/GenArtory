"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("@ethersproject/contracts");
const wallet_1 = require("@ethersproject/wallet");
const arbundles_1 = require("arbundles");
const base_1 = require("./base");
const ethereum_1 = tslib_1.__importDefault(require("./ethereum"));
const utils_1 = require("../../common/utils");
class ERC20Config extends ethereum_1.default {
    constructor(config) {
        super(config);
        this.contractAddress = config.contractAddress;
    }
    getContract() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.contractInstance) {
                this.contractInstance = new contracts_1.Contract(this.contractAddress, utils_1.erc20abi, new wallet_1.Wallet(this.wallet, yield this.getProvider()));
                this.base = ["wei", Math.pow(10, yield this.contractInstance.decimals())];
            }
            return this.contractInstance;
        });
    }
    getTx(txId) {
        const _super = Object.create(null, {
            getProvider: { get: () => super.getProvider }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield (yield _super.getProvider.call(this)).getTransaction(txId);
            if (!response)
                throw new Error("Tx doesn't exist");
            if (response.data.length !== 138 ||
                response.data.slice(2, 10) !== "a9059cbb" // standard ERC20-ABI method ID for transfers
            ) {
                throw new Error("Tx isn't a ERC20 transfer");
            }
            const to = `0x${response.data.slice(34, 74)}`;
            const amount = new bignumber_js_1.default(response.data.slice(74), 16);
            return {
                from: response.from,
                to,
                blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
                amount,
                pending: response.blockNumber ? false : true,
                confirmed: response.confirmations >= this.minConfirm,
            };
        });
    }
    getFee(amount, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
            const contract = yield this.getContract();
            const provider = yield this.getProvider();
            const gasPrice = yield provider.getGasPrice();
            const gasLimit = yield contract.estimateGas.transfer(to, _amount);
            const units = new bignumber_js_1.default(gasPrice.mul(gasLimit).toString()); // price in WEI
            return units;
            // below is cost in contract token units for the gas price
            // const [fiatGasPrice] = await this.getGas(); // get price of gas units
            // const value = fiatGasPrice.multipliedBy(units); // value of the fee
            // // convert value
            // const ctPrice = new BigNumber(await this.price()); // price for this token
            // const ctAmount = new BigNumber(value).dividedToIntegerBy(ctPrice);
            // // const b = ctAmount.multipliedBy(ctPrice)
            // // const c = value.dividedBy(this.base[1])
            // // console.log(b);
            // // console.log(c)
            // return ctAmount;
        });
    }
    createTx(amount, to, _fee) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const provider = yield this.getProvider();
            const wallet = new wallet_1.Wallet(this.wallet, provider);
            const contract = yield this.getContract();
            const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
            const tx = yield contract.populateTransaction.transfer(to, _amount);
            // Needed *specifically* for ERC20
            tx.gasPrice = yield provider.getGasPrice();
            tx.gasLimit = yield contract.estimateGas.transfer(to, _amount);
            tx.chainId = (yield provider.getNetwork()).chainId;
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            tx.nonce = yield provider.getTransactionCount(this.address);
            const signedTx = yield wallet.signTransaction(tx);
            const txId = "0x" + (0, arbundles_1.keccak256)(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
            return { txId, tx: signedTx };
        });
    }
    // TODO: create a nicer solution than just overrides (larger issue: some currencies aren't on redstone)
    getGas() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return [new bignumber_js_1.default(yield (0, base_1.getRedstonePrice)("ETH")), 1e18];
        });
    }
}
exports.default = ERC20Config;
//# sourceMappingURL=erc20.js.map