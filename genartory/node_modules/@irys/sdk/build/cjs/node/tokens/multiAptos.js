"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const aptos_1 = tslib_1.__importDefault(require("./aptos"));
const arbundles_1 = require("arbundles");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
class MultiSignatureAptos extends aptos_1.default {
    constructor(config) {
        var _a;
        super(config);
        this.collectSignatures = (_a = this === null || this === void 0 ? void 0 : this.opts) === null || _a === void 0 ? void 0 : _a.collectSignatures;
        this.needsFee = true;
    }
    /**
     * @param owner compound MultiEd25519PublicKey .toBytes()
     */
    ownerToAddress(pubKey) {
        // deserialise key
        const multiSigPublicKey = this.deserialisePubKey(pubKey);
        // derive address
        const authKey2 = ts_sdk_1.AuthenticationKey.fromPublicKeyAndScheme({ publicKey: multiSigPublicKey, scheme: ts_sdk_1.SigningScheme.MultiEd25519 });
        return authKey2.derivedAddress().toString();
    }
    deserialisePubKey(pubKey) {
        const threshold = +pubKey.slice(32 * 32).toString();
        const keys = [];
        const nullBuf = Buffer.alloc(32, 0);
        for (let i = 0; i < 32; i++) {
            const key = pubKey.subarray(i * 32, (i + 1) * 32);
            if (!key.equals(nullBuf))
                keys.push(new ts_sdk_1.Ed25519PublicKey(key));
        }
        // reconstruct key
        return new ts_sdk_1.MultiEd25519PublicKey({ publicKeys: keys, threshold });
    }
    getPublicKey() {
        const { participants, threshold } = this.wallet;
        const pkey = Buffer.alloc(32 * 32 + 1);
        participants.forEach((k, i) => {
            pkey.set(k, i * 32);
        });
        pkey.set(Buffer.from(threshold.toString()), 1024);
        return pkey;
    }
    getFee(amount, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            const transaction = yield client.transaction.build.simple({
                sender: this.address,
                data: {
                    function: "0x1::coin::transfer",
                    typeArguments: ["0x1::aptos_coin::AptosCoin"],
                    functionArguments: [to !== null && to !== void 0 ? to : "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new bignumber_js_1.default(amount).toNumber()],
                },
            });
            const accountAuthenticator = new ts_sdk_1.AccountAuthenticatorEd25519(new ts_sdk_1.Ed25519PublicKey(this.getPublicKey()), new ts_sdk_1.Ed25519Signature(new Uint8Array(64)));
            const transactionAuthenticator = new ts_sdk_1.TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);
            const signedSimulation = new ts_sdk_1.SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();
            const queryParams = {
                estimate_gas_unit_price: true,
                estimate_max_gas_amount: true,
            };
            const { data } = yield (0, ts_sdk_1.postAptosFullNode)({
                aptosConfig: this.aptosConfig,
                body: signedSimulation,
                path: "transactions/simulate",
                params: queryParams,
                originMethod: "simulateTransaction",
                contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
            });
            return { gasUnitPrice: +data[0].gas_unit_price, maxGasAmount: +data[0].max_gas_amount };
        });
    }
    createTx(amount, to, fee) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            const { participants, threshold } = this.wallet;
            const multiSigPublicKey = new ts_sdk_1.MultiEd25519PublicKey({ publicKeys: participants.map((v) => new ts_sdk_1.Ed25519PublicKey(v)), threshold });
            const authKey = ts_sdk_1.AuthenticationKey.fromPublicKeyAndScheme({ publicKey: multiSigPublicKey, scheme: ts_sdk_1.SigningScheme.MultiEd25519 });
            const mutisigAccountAddress = authKey.derivedAddress();
            const token = (0, ts_sdk_1.parseTypeTag)("0x1::aptos_coin::AptosCoin");
            const entryFunctionPayload = ts_sdk_1.EntryFunction.build(`0x1::coin`, `transfer`, [token], [ts_sdk_1.AccountAddress.from(to), new ts_sdk_1.U64(new bignumber_js_1.default(amount).toNumber())]);
            const [{ sequence_number: sequenceNumber }, chainId] = yield Promise.all([
                client.getAccountInfo({ accountAddress: mutisigAccountAddress }),
                client.getChainId(),
            ]);
            const rawTx = new ts_sdk_1.RawTransaction(
            // Transaction sender account address
            ts_sdk_1.AccountAddress.from(mutisigAccountAddress), BigInt(sequenceNumber), new ts_sdk_1.TransactionPayloadEntryFunction(entryFunctionPayload), 
            // Max gas unit to spend
            BigInt((_a = fee === null || fee === void 0 ? void 0 : fee.maxGasAmount) !== null && _a !== void 0 ? _a : 10000), 
            // Gas price per unit
            BigInt((_b = fee === null || fee === void 0 ? void 0 : fee.gasUnitPrice) !== null && _b !== void 0 ? _b : 100), 
            // Expiration timestamp. Transaction is discarded if it is not executed within 1000 seconds (16.6 minutes) from now.
            BigInt(Math.floor(Date.now() / 1000) + 1000), new ts_sdk_1.ChainId(chainId));
            return { tx: rawTx, txId: undefined };
        });
    }
    sendTx(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            const signingMessage = (0, ts_sdk_1.generateSigningMessage)(data);
            const { signatures, bitmap } = yield this.collectSignatures(signingMessage);
            const encodedBitmap = ts_sdk_1.MultiEd25519Signature.createBitmap({ bits: bitmap });
            const muliEd25519Sig = new ts_sdk_1.MultiEd25519Signature({ signatures: signatures.map((s) => new ts_sdk_1.Ed25519Signature(s)), bitmap: encodedBitmap });
            const authenticator = new ts_sdk_1.TransactionAuthenticatorMultiEd25519(this.deserialisePubKey(this.getPublicKey()), muliEd25519Sig);
            const bcsTxn = new ts_sdk_1.SignedTransaction(data, authenticator);
            const { data: postData } = yield (0, ts_sdk_1.postAptosFullNode)({
                aptosConfig: this.aptosConfig,
                body: bcsTxn,
                path: "transactions",
                originMethod: "submitTransaction",
                contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
            });
            yield client.waitForTransaction({ transactionHash: postData.hash });
            return postData.hash;
        });
    }
    getSigner() {
        var _a;
        if (this.signerInstance)
            return this.signerInstance;
        const pkey = Buffer.alloc(1025);
        const deserKey = this.deserialisePubKey(this.getPublicKey());
        deserKey.publicKeys.forEach((k, i) => {
            pkey.set(k.toUint8Array(), i * 32);
        });
        pkey.set(Buffer.from(deserKey.threshold.toString()), 1024);
        return ((_a = this.signerInstance) !== null && _a !== void 0 ? _a : (this.signerInstance = new arbundles_1.MultiSignatureAptosSigner(pkey, this.collectSignatures)));
    }
    ready() {
        const _super = Object.create(null, {
            ready: { get: () => super.ready }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield _super.ready.call(this);
        });
    }
    verify(pub, data, signature) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield arbundles_1.MultiSignatureAptosSigner.verify(pub, data, signature);
        });
    }
}
exports.default = MultiSignatureAptos;
//# sourceMappingURL=multiAptos.js.map