"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.augmentViemV2 = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/explicit-function-return-type */
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const web_1 = require("arbundles/web");
// TODO: figure out a better way to do this.
function augmentViemV2(tokenConfig, opts) {
    var _a;
    const walletClient = opts.provider;
    const publicClient = opts.publicClient;
    const accountIndex = (_a = opts.accountIndex) !== null && _a !== void 0 ? _a : 0;
    tokenConfig.ready = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.getSigner().ready();
            this._address = yield walletClient.getAddresses().then((r) => r[accountIndex].toString().toLowerCase());
            this.providerInstance = this.wallet;
        });
    }.bind(tokenConfig);
    tokenConfig.getFee = (_amount) => tslib_1.__awaiter(this, void 0, void 0, function* () { return new bignumber_js_1.default(0); });
    tokenConfig.getSigner = function () {
        if (!this.signer) {
            this.signer = new web_1.InjectedTypedEthereumSigner({
                getSigner: () => ({
                    getAddress: () => tslib_1.__awaiter(this, void 0, void 0, function* () { return walletClient.getAddresses().then((r) => r[accountIndex]); }),
                    _signTypedData: (domain, types, message) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        message["Transaction hash"] = "0x" + Buffer.from(message["Transaction hash"]).toString("hex");
                        // @ts-expect-error types
                        return yield walletClient.signTypedData({ account: message.address, domain, types, primaryType: "Bundlr", message });
                    }),
                }),
            });
        }
        return this.signer;
    }.bind(tokenConfig);
    tokenConfig.getCurrentHeight = () => tslib_1.__awaiter(this, void 0, void 0, function* () { return new bignumber_js_1.default((yield publicClient.getBlockNumber()).toString()); });
    // if this is ERC20
    if (tokenConfig.contractAddress) {
        throw new Error("viemv2 is not supported for ERC20 tokens");
    }
    else {
        // this is a full chain
        tokenConfig.getTx = (txId) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tx = yield publicClient.getTransaction({ hash: txId });
            const currentHeight = yield publicClient.getBlockNumber();
            return {
                to: tx.to,
                from: tx.from,
                blockHeight: new bignumber_js_1.default(tx.blockNumber.toString()),
                amount: new bignumber_js_1.default(tx.value.toString()),
                pending: tx.blockNumber ? false : true,
                confirmed: currentHeight - tx.blockNumber >= tokenConfig.minConfirm,
            };
        });
        tokenConfig.createTx = function (amount, to) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = {
                    account: tokenConfig.address,
                    to,
                    value: amount.toString(),
                };
                return {
                    txId: undefined,
                    tx: config,
                };
            });
        }.bind(tokenConfig);
        tokenConfig.sendTx = function (data) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return yield walletClient.sendTransaction({ account: data.account, to: data.to, value: data.value, chain: walletClient.chain });
            });
        };
    }
}
exports.augmentViemV2 = augmentViemV2;
//# sourceMappingURL=viemv2.js.map