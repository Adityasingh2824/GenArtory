"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const web_1 = require("arbundles/web");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const js_sha3_1 = tslib_1.__importDefault(require("js-sha3"));
const base_1 = tslib_1.__importDefault(require("./base"));
class AptosConfig extends base_1.default {
    constructor(config) {
        var _a;
        super(config);
        this.signingFn = (_a = config === null || config === void 0 ? void 0 : config.opts) === null || _a === void 0 ? void 0 : _a.signingFunction;
        this.base = ["octa", 1e8];
    }
    getProvider() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return ((_a = this.providerInstance) !== null && _a !== void 0 ? _a : (this.providerInstance = new ts_sdk_1.Aptos(this.aptosConfig)));
        });
    }
    getTx(txId) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            const tx = (yield client.waitForTransaction({ transactionHash: txId }));
            const payload = tx === null || tx === void 0 ? void 0 : tx.payload;
            if (!tx.success) {
                throw new Error((_a = tx === null || tx === void 0 ? void 0 : tx.vm_status) !== null && _a !== void 0 ? _a : "Unknown Aptos error");
            }
            if (!((payload === null || payload === void 0 ? void 0 : payload.function) === "0x1::coin::transfer" &&
                (payload === null || payload === void 0 ? void 0 : payload.type_arguments[0]) === "0x1::aptos_coin::AptosCoin" &&
                (tx === null || tx === void 0 ? void 0 : tx.vm_status) === "Executed successfully")) {
                throw new Error(`Aptos tx ${txId} failed validation`);
            }
            const isPending = tx.type === "pending_transaction";
            return {
                to: payload.arguments[0],
                from: tx.sender,
                amount: new bignumber_js_1.default(payload.arguments[1]),
                pending: isPending,
                confirmed: !isPending,
            };
        });
    }
    ownerToAddress(owner) {
        const hash = js_sha3_1.default.sha3_256.create();
        hash.update(Buffer.from(owner));
        hash.update("\x00");
        return `0x${hash.hex()}`;
    }
    sign(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.getSigner().sign(data);
        });
    }
    getSigner() {
        if (this.signerInstance)
            return this.signerInstance;
        if (this.signingFn) {
            const signer = new web_1.AptosSigner("", "0x" + this._publicKey.toString("hex"));
            signer.sign = this.signingFn; // override signer fn
            return (this.signerInstance = signer);
        }
        return (this.signerInstance = new web_1.InjectedAptosSigner(this.wallet, this._publicKey));
    }
    verify(pub, data, signature) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield web_1.InjectedAptosSigner.verify(pub, data, signature);
        });
    }
    getCurrentHeight() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return new bignumber_js_1.default((yield (yield this.getProvider()).getLedgerInfo()).block_height);
        });
    }
    getFee(amount, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const client = yield this.getProvider();
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            const transaction = yield client.transaction.build.simple({
                sender: this.address,
                data: {
                    function: "0x1::coin::transfer",
                    typeArguments: ["0x1::aptos_coin::AptosCoin"],
                    functionArguments: [to !== null && to !== void 0 ? to : "0x149f7dc9c8e43c14ab46d3a6b62cfe84d67668f764277411f98732bf6718acf9", new bignumber_js_1.default(amount).toNumber()],
                },
            });
            const accountAuthenticator = new ts_sdk_1.AccountAuthenticatorEd25519(new ts_sdk_1.Ed25519PublicKey(yield this.getPublicKey()), new ts_sdk_1.Ed25519Signature(new Uint8Array(64)));
            const transactionAuthenticator = new ts_sdk_1.TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);
            const signedSimulation = new ts_sdk_1.SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();
            const queryParams = {
                estimate_gas_unit_price: true,
                estimate_max_gas_amount: true,
            };
            const { data } = yield (0, ts_sdk_1.postAptosFullNode)({
                aptosConfig: this.aptosConfig,
                body: signedSimulation,
                path: "transactions/simulate",
                params: queryParams,
                originMethod: "simulateTransaction",
                contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
            });
            return { gasUnitPrice: +data[0].gas_unit_price, maxGasAmount: +data[0].max_gas_amount };
            // const simulationResult = await client.simulateTransaction(this.accountInstance, rawTransaction, { estimateGasUnitPrice: true, estimateMaxGasAmount: true });
            // return new BigNumber(simulationResult?.[0].gas_unit_price).multipliedBy(simulationResult?.[0].gas_used);
            // const est = await provider.client.transactions.estimateGasPrice();
            // return new BigNumber(est.gas_estimate/* (await (await this.getProvider()).client.transactions.estimateGasPrice()).gas_estimate */); // * by gas limit (for upper limit)
        });
    }
    sendTx(data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.signingFn)
                return (yield this.wallet.signAndSubmitTransaction(data)).hash;
            // return (await (await (this.getProvider())).submitSignedBCSTransaction(data)).hash;
            const provider = yield this.getProvider();
            const { data: postData } = yield (0, ts_sdk_1.postAptosFullNode)({
                aptosConfig: this.aptosConfig,
                body: data,
                path: "transactions",
                originMethod: "submitTransaction",
                contentType: ts_sdk_1.MimeType.BCS_SIGNED_TRANSACTION,
            });
            yield provider.waitForTransaction({ transactionHash: postData.hash });
            return postData.hash;
        });
    }
    createTx(amount, to, fee) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const txData = {
                sender: this.address,
                data: {
                    function: "0x1::coin::transfer",
                    typeArguments: ["0x1::aptos_coin::AptosCoin"],
                    functionArguments: [to, new bignumber_js_1.default(amount).toNumber()],
                },
                options: {
                    gasUnitPrice: (_a = fee === null || fee === void 0 ? void 0 : fee.gasUnitPrice) !== null && _a !== void 0 ? _a : 100,
                    maxGasAmount: (_b = fee === null || fee === void 0 ? void 0 : fee.maxGasAmount) !== null && _b !== void 0 ? _b : 10,
                },
            };
            if (!this.signingFn)
                return { txId: undefined, tx: txData };
            const client = yield this.getProvider();
            // @ts-expect-error type issue
            const transaction = yield client.transaction.build.simple(txData);
            const message = (0, ts_sdk_1.generateSigningMessage)(transaction);
            const signerSignature = yield this.sign(message);
            const senderAuthenticator = new ts_sdk_1.AccountAuthenticatorEd25519(new ts_sdk_1.Ed25519PublicKey(yield this.getPublicKey()), new ts_sdk_1.Ed25519Signature(signerSignature));
            const signedTransaction = (0, ts_sdk_1.generateSignedTransaction)({ transaction, senderAuthenticator });
            return { txId: undefined, tx: signedTransaction };
        });
    }
    getPublicKey() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return ((_a = this._publicKey) !== null && _a !== void 0 ? _a : (this._publicKey = this.signingFn
                ? Buffer.from(this.wallet.slice(2), "hex")
                : Buffer.from(this.wallet.account.publicKey.toString().slice(2), "hex")));
        });
    }
    ready() {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // In the Aptos context, this.providerUrl is the Aptos Network enum type we want
            // to work with. read more https://github.com/aptos-labs/aptos-ts-sdk/blob/main/src/api/aptosConfig.ts#L14
            // this.providerUrl is a Network enum type represents the current configured network
            this.aptosConfig = new ts_sdk_1.AptosConfig(Object.assign({ network: this.providerUrl }, (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.aptosSdkConfig));
            this._publicKey = (yield this.getPublicKey());
            this._address = this.ownerToAddress(this._publicKey);
            const client = yield this.getProvider();
            this._address = yield client
                .lookupOriginalAccountAddress({ authenticationKey: (_c = this.address) !== null && _c !== void 0 ? _c : "" })
                .then((hs) => hs.toString())
                .catch((_) => this._address); // fallback to original
            if (((_d = this._address) === null || _d === void 0 ? void 0 : _d.length) == 66 && this._address.charAt(2) === "0") {
                this._address = this._address.slice(0, 2) + this._address.slice(3);
            }
        });
    }
}
exports.default = AptosConfig;
//# sourceMappingURL=aptos.js.map