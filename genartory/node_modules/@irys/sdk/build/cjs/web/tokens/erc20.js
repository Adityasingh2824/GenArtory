"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const contracts_1 = require("@ethersproject/contracts");
const ethereum_1 = tslib_1.__importDefault(require("./ethereum"));
const utils_1 = require("../../common/utils");
class ERC20Config extends ethereum_1.default {
    constructor(config) {
        super(config);
        this.contractAddress = config.contractAddress;
    }
    getContract() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.contractInstance) {
                // @ts-expect-error minimal type
                this.contractInstance = new contracts_1.Contract(this.contractAddress, utils_1.erc20abi, this.w3signer);
                this.base = ["wei", Math.pow(10, yield this.contractInstance.decimals())];
            }
            return this.contractInstance;
        });
    }
    getTx(txId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield this.providerInstance.getTransaction(txId);
            if (!response)
                throw new Error("Tx doesn't exist");
            if (response.data.length !== 138 ||
                response.data.slice(2, 10) !== "a9059cbb" // standard ERC20-ABI method ID for transfers
            ) {
                throw new Error("Tx isn't a ERC20 transfer");
            }
            const to = `0x${response.data.slice(34, 74)}`;
            const amount = new bignumber_js_1.default(response.data.slice(74), 16);
            return {
                from: response.from,
                to,
                blockHeight: response.blockNumber ? new bignumber_js_1.default(response.blockNumber) : undefined,
                amount,
                pending: response.blockNumber ? false : true,
                confirmed: response.confirmations >= this.minConfirm,
            };
        });
    }
    getFee(amount, to) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
            const contract = yield this.getContract();
            const gasPrice = yield this.providerInstance.getGasPrice();
            const gasLimit = yield contract.estimateGas.transfer(to, _amount);
            const units = new bignumber_js_1.default(gasPrice.mul(gasLimit).toString()); // price in WEI
            return units;
        });
    }
    createTx(amount, to, _fee) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // const provider = await this.getProvider()
            // const wallet = new Wallet(this.wallet, this.providerInstance);
            const contract = yield this.getContract();
            const _amount = "0x" + new bignumber_js_1.default(amount).toString(16);
            const tx = yield contract.populateTransaction.transfer(to, _amount);
            // Needed *specifically* for ERC20
            tx.gasPrice = yield this.providerInstance.getGasPrice();
            tx.gasLimit = yield contract.estimateGas.transfer(to, _amount);
            tx.chainId = (yield this.providerInstance.getNetwork()).chainId;
            if (!this.address)
                throw new Error("Address is undefined - you might be missing a wallet, or have not run Irys.ready()");
            tx.nonce = yield this.providerInstance.getTransactionCount(this.address);
            // const txr = this.w3signer.populateTransaction()
            // const signedTx = await this.wallet.signTransaction(tx);
            // const txId = "0x" + keccak256(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
            return { txId: undefined, tx: tx };
        });
    }
}
exports.default = ERC20Config;
//# sourceMappingURL=erc20.js.map