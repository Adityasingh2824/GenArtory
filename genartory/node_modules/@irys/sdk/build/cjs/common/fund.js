"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Fund = void 0;
const tslib_1 = require("tslib");
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const utils_1 = tslib_1.__importDefault(require("./utils"));
class Fund {
    constructor(utils) {
        this.utils = utils;
    }
    /**
     * Function to Fund (send funds to) a Irys node - inherits instance token and node
     * @param amount - amount in base units to send
     * @param multiplier - network tx fee multiplier - only works for specific currencies
     * @returns  - funding receipt
     */
    fund(amount, multiplier = 1.0) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            amount = new bignumber_js_1.default(amount);
            if (!amount.isInteger()) {
                throw new Error("must use an integer for funding amount");
            }
            const c = this.utils.tokenConfig;
            const to = yield this.utils.getBundlerAddress(this.utils.token);
            let fee = c.needsFee ? yield c.getFee(amount, to, multiplier) : undefined;
            // if fee is defined, is a bigNumber, and getFee doesn't accept the multiplier arg, apply multiplier here.
            // tokens should now handle multipliers within getFee, this is a temporary transitionary measure.
            if (fee && bignumber_js_1.default.isBigNumber(fee) && c.getFee.length < 3)
                fee = fee.multipliedBy(multiplier).integerValue();
            const tx = yield c.createTx(amount, to, fee);
            const sendTxRes = yield c.sendTx(tx.tx);
            (_a = tx.txId) !== null && _a !== void 0 ? _a : (tx.txId = sendTxRes);
            if (!tx.txId)
                throw new Error(`Undefined transaction ID`);
            // Utils.checkAndThrow(sendTxRes, `Sending transaction to the ${this.utils.token} network`);
            let confirmError = yield this.utils.confirmationPoll(tx.txId);
            const bres = yield this.submitTransaction(tx.txId).catch((e) => {
                confirmError = e;
                return undefined;
            });
            if (!bres) {
                throw new Error(`failed to post funding tx - ${tx.txId} - keep this id! \n ${confirmError ? ` - ${(_b = confirmError === null || confirmError === void 0 ? void 0 : confirmError.message) !== null && _b !== void 0 ? _b : confirmError}` : ""}`);
            }
            return { reward: bignumber_js_1.default.isBigNumber(fee) ? fee.toString() : JSON.stringify(fee), target: to, quantity: amount.toString(), id: tx.txId };
        });
    }
    submitTransaction(transactionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (0, async_retry_1.default)(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const bres = yield this.utils.api.post(`/account/balance/${this.utils.token}`, { tx_id: transactionId });
                utils_1.default.checkAndThrow(bres, `Posting transaction ${transactionId} information to the bundler`, [202]);
                return bres;
            }), {
                retries: 5,
                maxTimeout: 1000,
                minTimeout: 100,
                randomize: true,
            });
        });
    }
    submitFundTransaction(transactionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.submitTransaction(transactionId);
        });
    }
}
exports.Fund = Fund;
exports.default = Fund;
//# sourceMappingURL=fund.js.map