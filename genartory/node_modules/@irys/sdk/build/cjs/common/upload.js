"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uploader = exports.CHUNKING_THRESHOLD = exports.sleep = void 0;
const tslib_1 = require("tslib");
/* eslint-disable no-case-declarations */
const promise_pool_1 = require("@supercharge/promise-pool");
const arbundles_1 = require("arbundles");
const base64url_1 = tslib_1.__importDefault(require("base64url"));
const chunkingUploader_1 = require("./chunkingUploader");
const types_1 = require("./types");
const crypto_1 = require("crypto");
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const utils_1 = require("./utils");
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
exports.sleep = sleep;
exports.CHUNKING_THRESHOLD = 50000000;
// eslint-disable-next-line @typescript-eslint/naming-convention
class Uploader {
    constructor(api, utils, token, tokenConfig, irysTransaction) {
        this.api = api;
        this.token = token;
        this.tokenConfig = tokenConfig;
        this.arbundles = this.tokenConfig.irys.arbundles;
        this.utils = utils;
        this.irysTransaction = irysTransaction;
    }
    uploadTransaction(transaction, opts) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let res;
            const isDataItem = this.arbundles.DataItem.isDataItem(transaction);
            if (this.forceUseChunking || (isDataItem && transaction.getRaw().length >= exports.CHUNKING_THRESHOLD) || !isDataItem) {
                res = yield this.chunkedUploader.uploadTransaction(isDataItem ? transaction.getRaw() : transaction, opts);
            }
            else {
                const { url, timeout, headers: confHeaders } = this.api.getConfig();
                const headers = Object.assign({ "Content-Type": "application/octet-stream" }, confHeaders);
                if (opts === null || opts === void 0 ? void 0 : opts.paidBy)
                    headers[types_1.UploadHeaders.PAID_BY] = opts.paidBy;
                res = yield this.api.post(new URL(`/tx/${this.token}`, url).toString(), transaction.getRaw(), {
                    headers: headers,
                    timeout,
                    maxBodyLength: Infinity,
                });
                if (res.status === 201) {
                    throw new Error(res.data);
                }
            }
            switch (res.status) {
                case 402:
                    const retryAfterHeader = (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a["retry-after"];
                    const errorMsg = "402 error: " + res.data + (retryAfterHeader ? ` - retry after ${retryAfterHeader}s` : "");
                    throw new Error(errorMsg);
                default:
                    if (res.status >= 400) {
                        throw new Error(`whilst uploading Irys transaction: ${res.status} ${(0, utils_1.httpErrData)(res)}`);
                    }
            }
            res.data.verify = () => tslib_1.__awaiter(this, void 0, void 0, function* () { return this.utils.verifyReceipt(res.data); });
            return res;
        });
    }
    uploadData(data, opts) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (typeof data === "string") {
                data = Buffer.from(data);
            }
            if (Buffer.isBuffer(data)) {
                if (data.length <= exports.CHUNKING_THRESHOLD) {
                    const dataItem = this.arbundles.createData(data, this.tokenConfig.getSigner(), Object.assign(Object.assign({}, opts), { anchor: (_a = opts === null || opts === void 0 ? void 0 : opts.anchor) !== null && _a !== void 0 ? _a : (0, crypto_1.randomBytes)(32).toString("base64").slice(0, 32) }));
                    yield dataItem.sign(this.tokenConfig.getSigner());
                    return (yield this.uploadTransaction(dataItem, Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.upload))).data;
                }
            }
            return (yield this.chunkedUploader.uploadData(data, opts)).data;
        });
    }
    // concurrently uploads transactions
    concurrentUploader(data, opts) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const errors = [];
            const logFn = (opts === null || opts === void 0 ? void 0 : opts.logFunction)
                ? opts === null || opts === void 0 ? void 0 : opts.logFunction
                : (_) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return;
                });
            const concurrency = (_a = opts === null || opts === void 0 ? void 0 : opts.concurrency) !== null && _a !== void 0 ? _a : 5;
            const results = (yield promise_pool_1.PromisePool.for(data)
                .withConcurrency(concurrency >= 1 ? concurrency : 5)
                .handleError((error, _, pool) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                errors.push(error);
                if (error.message.includes("402 error")) {
                    pool.stop();
                    throw error;
                }
            }))
                .process((item, i) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield (0, async_retry_1.default)((bail) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    try {
                        const res = yield this.processItem(item, opts === null || opts === void 0 ? void 0 : opts.itemOptions);
                        if (i % concurrency == 0) {
                            yield logFn(`Processed ${i} Items`);
                        }
                        if (opts === null || opts === void 0 ? void 0 : opts.resultProcessor) {
                            return yield opts.resultProcessor({ item, res, i });
                        }
                        else {
                            return { item, res, i };
                        }
                    }
                    catch (e) {
                        if (e === null || e === void 0 ? void 0 : e.message.includes("402 error")) {
                            bail(e);
                        }
                        throw e;
                    }
                }), { retries: 3, minTimeout: 1000, maxTimeout: 10000 });
            })));
            return { errors, results: results.results };
        });
    }
    processItem(data, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.arbundles.DataItem.isDataItem(data)) {
                return this.uploadTransaction(data, Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.upload));
            }
            return this.uploadData(data, opts);
        });
    }
    /**
     * geneates a manifest JSON object
     * @param config.items mapping of logical paths to item IDs
     * @param config.indexFile optional logical path of the index file for the manifest
     * @returns
     */
    generateManifest(config) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { items, indexFile } = config;
            const manifest = {
                manifest: "arweave/paths",
                version: "0.1.0",
                paths: {},
            };
            if (indexFile) {
                if (!items.has(indexFile)) {
                    throw new Error(`Unable to access item: ${indexFile}`);
                }
                manifest.index = { path: indexFile };
            }
            for (const [k, v] of items.entries()) {
                // @ts-expect-error constant index type
                manifest.paths[k] = { id: v };
            }
            return manifest;
        });
    }
    get chunkedUploader() {
        return new chunkingUploader_1.ChunkingUploader(this.tokenConfig, this.api);
    }
    set useChunking(state) {
        if (typeof state === "boolean") {
            this.forceUseChunking = state;
        }
    }
    set contentType(type) {
        // const fullType = mime.contentType(type)
        // if(!fullType){
        //     throw new Error("Invali")
        // }
        this.contentTypeOverride = type;
    }
    uploadBundle(transactions, opts) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const throwawayKey = (_a = opts === null || opts === void 0 ? void 0 : opts.throwawayKey) !== null && _a !== void 0 ? _a : (yield this.arbundles.getCryptoDriver().generateJWK());
            const ephemeralSigner = new arbundles_1.ArweaveSigner(throwawayKey);
            const txs = transactions.map((tx) => (this.arbundles.DataItem.isDataItem(tx) ? tx : this.arbundles.createData(tx, ephemeralSigner)));
            const bundle = yield this.arbundles.bundleAndSignData(txs, ephemeralSigner);
            // upload bundle with bundle specific tags, use actual signer for this.
            const tx = this.arbundles.createData(bundle.getRaw(), this.tokenConfig.getSigner(), {
                tags: [
                    { name: "Bundle-Format", value: "binary" },
                    { name: "Bundle-Version", value: "2.0.0" },
                ],
            });
            yield tx.sign(this.tokenConfig.getSigner());
            const res = yield this.uploadTransaction(tx, opts);
            const throwawayKeyAddress = (0, base64url_1.default)(Buffer.from(yield this.arbundles.getCryptoDriver().hash(base64url_1.default.toBuffer((0, base64url_1.default)(ephemeralSigner.publicKey)))));
            return Object.assign(Object.assign({}, res), { txs, throwawayKey, throwawayKeyAddress });
        });
    }
}
exports.Uploader = Uploader;
exports.default = Uploader;
//# sourceMappingURL=upload.js.map