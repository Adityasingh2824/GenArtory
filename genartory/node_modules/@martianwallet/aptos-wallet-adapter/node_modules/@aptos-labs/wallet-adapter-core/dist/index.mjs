// src/WalletCore.ts
import { HexString } from "aptos";
import EventEmitter from "eventemitter3";
import nacl from "tweetnacl";
import { Buffer } from "buffer";

// src/constants.ts
var WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = /* @__PURE__ */ ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});

// src/error/index.ts
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};

// src/utils/scopePollingDetectionStrategy.ts
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}

// src/utils/localStorage.ts
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}

// src/ans.ts
var ChainIdToAnsContractAddressMap = {
  "1": "mainnet",
  "2": "testnet"
};
var getNameByAddress = async (chainId, address) => {
  try {
    if (!ChainIdToAnsContractAddressMap[chainId])
      return null;
    const response = await fetch(
      `https://www.aptosnames.com/api/${ChainIdToAnsContractAddressMap[chainId]}/v1/name/${address}`
    );
    const data = await response.json();
    return data.name;
  } catch (e) {
    console.log("error", e);
    return null;
  }
};

// src/WalletCore.ts
var WalletCore = class extends EventEmitter {
  constructor(plugins) {
    super();
    this._wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this._connecting = false;
    this._connected = false;
    this._wallets = plugins;
    this.scopePollingDetectionStrategy();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" /* Unsupported */ : "NotDetected" /* NotDetected */;
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed" /* Installed */;
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" /* Loadable */ || this._wallet.readyState === "Installed" /* Installed */))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      const name = await getNameByAddress(
        this._network.chainId,
        this._account.address
      );
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    this._account = account;
  }
  setNetwork(network) {
    this._network = network;
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a, _b;
    try {
      const selectedWallet = (_a = this._wallets) == null ? void 0 : _a.find(
        (wallet) => wallet.name === walletName
      );
      if (!selectedWallet || selectedWallet.readyState !== "Installed" /* Installed */ && selectedWallet.readyState !== "Loadable" /* Loadable */) {
        return;
      }
      if (this._connected) {
        if (((_b = this.wallet) == null ? void 0 : _b.name) === walletName)
          return;
        await this.disconnect();
      }
      this._connecting = true;
      this.setWallet(selectedWallet);
      const account = await selectedWallet.connect();
      this.setAccount({ ...account });
      const network = await selectedWallet.network();
      this.setNetwork({ ...network });
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      throw new WalletConnectionError(error).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.disconnect());
      this.clearData();
      this.emit("disconnect");
    } catch (error) {
      throw new WalletDisconnectionError(error).message;
    }
  }
  async signAndSubmitTransaction(transaction) {
    var _a;
    try {
      this.doesWalletExist();
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signAndSubmitTransaction(
        transaction
      ));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction) {
    var _a;
    if (this._wallet && !("signAndSubmitBCSTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signAndSubmitBCSTransaction(
        transaction
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction) {
    var _a;
    if (this._wallet && !("signTransaction" in this._wallet)) {
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_a = this.wallet) == null ? void 0 : _a.name}`
      ).message;
    }
    try {
      this.doesWalletExist();
      const response = await this._wallet.signTransaction(transaction);
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._wallet)
        return null;
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async onAccountChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onAccountChange(async (data) => {
        this.setAccount({ ...data });
        await this.setAnsName();
        this.emit("accountChange", this._account);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    var _a;
    try {
      this.doesWalletExist();
      await ((_a = this._wallet) == null ? void 0 : _a.onNetworkChange(async (data) => {
        this.setNetwork({ ...data });
        await this.setAnsName();
        this.emit("networkChange", this._network);
      }));
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    var _a;
    try {
      this.doesWalletExist();
      if (!this._account)
        throw new Error("No account found!");
      const response = await ((_a = this._wallet) == null ? void 0 : _a.signMessage(message));
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = this._account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n) => Array.from({ length: 8 }).map((_, i) => n >> i & 1)
            );
            const index = bits.map((_, i) => i).filter((i) => bits[i]);
            const publicKeys = this._account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i) => index.includes(i)
            );
            verified = true;
            for (let i = 0; i < signature.length; i++) {
              const isSigVerified = nacl.sign.detached.verify(
                Buffer.from(fullMessage),
                Buffer.from(signature[i], "hex"),
                Buffer.from(matchedPublicKeys[i], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          this._account.publicKey
        );
        const signature = new HexString(response.signature);
        verified = nacl.sign.detached.verify(
          Buffer.from(response.fullMessage),
          Buffer.from(signature.noPrefix(), "hex"),
          Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
export {
  NetworkName,
  WalletCore,
  WalletReadyState
};
