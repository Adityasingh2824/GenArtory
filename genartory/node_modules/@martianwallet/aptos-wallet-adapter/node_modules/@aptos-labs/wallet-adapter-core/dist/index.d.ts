import { Types, TxnBuilderTypes } from 'aptos';
import EventEmitter from 'eventemitter3';

declare enum WalletReadyState {
    /**
     * User-installable wallets can typically be detected by scanning for an API
     * that they've injected into the global context. If such an API is present,
     * we consider the wallet to have been installed.
     */
    Installed = "Installed",
    NotDetected = "NotDetected",
    /**
     * Loadable wallets are always available to you. Since you can load them at
     * any time, it's meaningless to say that they have been detected.
     */
    Loadable = "Loadable",
    /**
     * If a wallet is not supported on a given platform (eg. server-rendering, or
     * mobile) then it will stay in the `Unsupported` state.
     */
    Unsupported = "Unsupported"
}
declare enum NetworkName {
    Mainnet = "mainnet",
    Testnet = "testnet",
    Devnet = "devnet"
}

declare type WalletName<T extends string = string> = T & {
    __brand__: "WalletName";
};
declare type NetworkInfo = {
    name: NetworkName;
    chainId?: string;
    url?: string;
};
declare type AccountInfo = {
    address: string;
    publicKey: string | string[];
    minKeysRequired?: number;
    ansName?: string | null;
};
interface AptosWalletErrorResult {
    code: number;
    name: string;
    message: string;
}
interface PluginProvider {
    connect: () => Promise<AccountInfo>;
    account: () => Promise<AccountInfo>;
    disconnect: () => Promise<void>;
    signAndSubmitTransaction: (transaction: any, options?: any) => Promise<{
        hash: Types.HexEncodedBytes;
    } | AptosWalletErrorResult>;
    signMessage: (message: SignMessagePayload) => Promise<SignMessageResponse>;
    network: () => Promise<NetworkName>;
    onAccountChange: (listener: (newAddress: AccountInfo) => Promise<void>) => Promise<void>;
    onNetworkChange: (listener: (network: {
        networkName: NetworkInfo;
    }) => Promise<void>) => Promise<void>;
}
interface AdapterPluginEvents {
    onNetworkChange(callback: any): Promise<any>;
    onAccountChange(callback: any): Promise<any>;
}
interface AdapterPluginProps<Name extends string = string> {
    name: WalletName<Name>;
    url: string;
    icon: `data:image/${"svg+xml" | "webp" | "png" | "gif"};base64,${string}`;
    providerName?: string;
    provider: any;
    connect(): Promise<any>;
    disconnect: () => Promise<any>;
    network: () => Promise<any>;
    signAndSubmitTransaction<T extends Types.TransactionPayload, V>(transaction: T, options?: V): Promise<{
        hash: Types.HexEncodedBytes;
    }>;
    signMessage<T extends SignMessagePayload>(message: T): Promise<SignMessageResponse>;
}
declare type AdapterPlugin<Name extends string = string> = AdapterPluginProps<Name> & AdapterPluginEvents;
declare type Wallet<Name extends string = string> = AdapterPlugin<Name> & {
    readyState?: WalletReadyState;
};
declare type WalletInfo = {
    name: WalletName;
    icon: string;
    url: string;
};
declare interface WalletCoreEvents {
    connect(account: AccountInfo | null): void;
    disconnect(): void;
    readyStateChange(wallet: Wallet): void;
    networkChange(network: NetworkInfo | null): void;
    accountChange(account: AccountInfo | null): void;
}
interface SignMessagePayload {
    address?: boolean;
    application?: boolean;
    chainId?: boolean;
    message: string;
    nonce: string;
}
interface SignMessageResponse {
    address?: string;
    application?: string;
    chainId?: number;
    fullMessage: string;
    message: string;
    nonce: string;
    prefix: "APTOS";
    signature: string | string[];
    bitmap?: Uint8Array;
}

declare class WalletCore extends EventEmitter<WalletCoreEvents> {
    private _wallets;
    private _wallet;
    private _account;
    private _network;
    private _connecting;
    private _connected;
    constructor(plugins: Wallet[]);
    private scopePollingDetectionStrategy;
    private doesWalletExist;
    private clearData;
    private setAnsName;
    setWallet(wallet: Wallet | null): void;
    setAccount(account: AccountInfo | null): void;
    setNetwork(network: NetworkInfo | null): void;
    isConnected(): boolean;
    get wallets(): Wallet[];
    /**
     * Getter for the current connected wallet
     * @return wallet info
     * @throws WalletNotSelectedError
     */
    get wallet(): WalletInfo | null;
    /**
     * Getter for the current connected account
     * @return account info
     * @throws WalletAccountError
     */
    get account(): AccountInfo | null;
    /**
     * Getter for the current wallet network
     * @return network info
     * @throws WalletGetNetworkError
     */
    get network(): NetworkInfo | null;
    /**
    Connects a wallet to the app. If a wallet is already connected,
    we first disconnect the current connected wallet and then connect the selected wallet.
    On connect success, we set the current account and the network, and keeping the selected wallet
    name in LocalStorage to support autoConnect function.
  
    @param walletName. The wallet name we want to connect as a WalletName type.
    @emit emits "connect" event
    @throws WalletConnectionError
    */
    connect(walletName: WalletName): Promise<void>;
    /**
    Disconnect the exisitng wallet. On success, we clear the
    current account, current network and LocalStorage data.
    @emit emits "disconnect" event
    @throws WalletDisconnectionError
    */
    disconnect(): Promise<void>;
    /**
    Sign and submit an entry (not bcs serialized) transaction type to chain.
    @param transaction a non-bcs serialized transaction
    @return response from the wallet's signAndSubmitTransaction function
    @throws WalletSignAndSubmitMessageError
    */
    signAndSubmitTransaction(transaction: Types.TransactionPayload): Promise<any>;
    /**
    Sign and submit a bsc serialized transaction type to chain.
    @param transaction a bcs serialized transaction
    @return response from the wallet's signAndSubmitBCSTransaction function
    @throws WalletSignAndSubmitMessageError
    */
    signAndSubmitBCSTransaction(transaction: TxnBuilderTypes.TransactionPayload): Promise<any>;
    /**
    Sign transaction (doesnt submit to chain).
    @param transaction
    @return response from the wallet's signTransaction function
    @throws WalletSignTransactionError
    */
    signTransaction(transaction: Types.TransactionPayload): Promise<Uint8Array | null>;
    /**
    Sign message (doesnt submit to chain).
    @param message
    @return response from the wallet's signMessage function
    @throws WalletSignMessageError
    */
    signMessage(message: SignMessagePayload): Promise<SignMessageResponse | null>;
    /**
    Event for when account has changed on the wallet
    @return the new account info
    @throws WalletAccountChangeError
    */
    onAccountChange(): Promise<void>;
    /**
    Event for when network has changed on the wallet
    @return the new network info
    @throws WalletNetworkChangeError
    */
    onNetworkChange(): Promise<void>;
    signMessageAndVerify(message: SignMessagePayload): Promise<boolean>;
}

export { AccountInfo, AdapterPlugin, AdapterPluginEvents, AdapterPluginProps, AptosWalletErrorResult, NetworkInfo, NetworkName, PluginProvider, SignMessagePayload, SignMessageResponse, Wallet, WalletCore, WalletCoreEvents, WalletInfo, WalletName, WalletReadyState };
