{"version":3,"sources":["../src/ACDappClient.ts","../src/constants.ts","../src/PairingClient.ts","../src/errors.ts","../src/state.ts","../src/utils.ts","../src/ICDappClient.ts","../src/prompt.ts","../src/KeylessClient.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  chainIdToNetwork,\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  makeUserApproval,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  AnySignature,\n  AnyTransactionPayloadInstance,\n  AptosConfig,\n  Deserializer,\n  Ed25519Signature,\n  FeePayerRawTransaction,\n  generateRawTransaction,\n  generateTransactionPayload,\n  generateTransactionPayloadWithABI,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { NetworkName } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { SignAndSubmitTransactionRequestArgs } from '@identity-connect/wallet-api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { ACPairingClient } from './PairingClient';\n\nexport interface WithSignerAddress {\n  signerAddress: AccountAddress;\n}\n\nexport interface ACDappClientConfig {\n  backendBaseURL?: string;\n  dappId?: string;\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n}\n\nexport class ACDappClient {\n  private readonly defaultNetworkName: NetworkName;\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  private readonly dappId?: string;\n  private readonly pairingClient: ACPairingClient;\n\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n  }: ACDappClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL);\n\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL,\n      },\n      defaultNetworkName,\n    });\n  }\n\n  // region Public API\n\n  private async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  private async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n\n  private async isIcAccount(address: AccountAddressInput) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find((account) => account.address.equals(AccountAddress.from(address))) !== undefined;\n  }\n\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n\n  async disconnect(address: AccountAddressInput) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n\n  async connect() {\n    const dappKeypair = createEd25519KeyPair();\n\n    const requestArgs = {\n      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n    };\n\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n\n    if (response.args.status === 'approved') {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({ account });\n    }\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = chainIdToNetwork(chainId) as string;\n\n      let message: string;\n      let nonce: string;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error('Only UTF-8 encoded text is supported when using IC');\n      }\n\n      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(\n        signerAddress.toString(),\n        {\n          address: true,\n          application: true,\n          chainId: true,\n          message,\n          nonce,\n        },\n        { networkName: network as NetworkName },\n      );\n\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature =\n        signatureBytes.length === Ed25519Signature.LENGTH\n          ? new Ed25519Signature(signatureBytes)\n          : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval<SignMessageResponse.ApprovalArgs>({\n        fullMessage,\n        signature,\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: (SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction) & WithSignerAddress,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber,\n      } = normalizedArgs;\n\n      if (feePayer !== undefined) {\n        throw new Error('Sponsored transaction not currently supported');\n      }\n\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error('Multi-agent transactions not currently supported');\n      }\n\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber: sequenceNumber !== undefined ? Number(sequenceNumber) : undefined,\n          },\n          payload,\n        },\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn,\n      });\n    }\n\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;\n      const aptosConfig = new AptosConfig({ network });\n\n      // Generate payload from input if needed\n      let payload: AnyTransactionPayloadInstance;\n      if ('bcsToBytes' in args.payload) {\n        payload = args.payload as AnyTransactionPayloadInstance;\n      } else if ('bytecode' in args.payload) {\n        payload = await generateTransactionPayload(args.payload);\n      } else {\n        payload =\n          args.payload.abi !== undefined\n            ? generateTransactionPayloadWithABI({ ...args.payload, abi: args.payload.abi })\n            : await generateTransactionPayload({ aptosConfig, ...args.payload });\n      }\n\n      let convertedArgs: SignAndSubmitTransactionRequestArgs;\n      if (feePayer !== undefined) {\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n          sender: signerAddress,\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address),\n        };\n      } else {\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n        };\n      }\n\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network as NetworkName | undefined,\n      });\n      return makeUserApproval<SignAndSubmitTransactionResponse.ApprovalArgs>({ txnHash: hash });\n    }\n\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_FRONTEND_URL = 'https://aptosconnect.app';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\nimport { AccountInfo } from '@aptos-connect/wallet-api';\nimport { AccountAddress } from '@aptos-labs/ts-sdk';\nimport {\n  CancelSigningRequestSerializedResponse,\n  CreateSigningRequestSerializedResponse,\n  FinalizedPairingData,\n  GetPairingSerializedResponse,\n  GetSigningRequestSerializedResponse,\n  NetworkName,\n  SerializedDate,\n  SigningRequestData,\n  SigningRequestStatus,\n  SigningRequestTypes,\n} from '@identity-connect/api';\nimport {\n  decodeBase64,\n  decryptEnvelope,\n  deserializeEd25519PublicKeyB64,\n  deserializePublicKeyB64,\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  encryptAndSignEnvelope,\n  KeyTypes,\n  toKey,\n} from '@identity-connect/crypto';\nimport {\n  deserializeSignTransactionResponseArgs,\n  type SerializedSignAndSubmitTransactionRequestArgs,\n  type SerializedSignTransactionRequestArgs,\n  type SerializedSignTransactionResponseArgs,\n  serializeSignAndSubmitTransactionRequestArgs,\n  serializeSignTransactionRequestArgs,\n  type SignAndSubmitTransactionRequestArgs,\n  type SignAndSubmitTransactionResponseArgs,\n  SignMessageRequestArgs,\n  SignMessageResponseArgs,\n  type SignTransactionRequestArgs,\n  type SignTransactionResponseArgs,\n  type SignTransactionWithPayloadRequestArgs,\n  type SignTransactionWithPayloadResponseArgs,\n  type SignTransactionWithRawTxnRequestArgs,\n  type SignTransactionWithRawTxnResponseArgs,\n} from '@identity-connect/wallet-api';\nimport axios, { AxiosError, AxiosInstance, CreateAxiosDefaults, isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { PairingExpiredError, SignatureRequestError } from './errors';\nimport { DappPairingData, DappStateAccessors, windowStateAccessors } from './state';\nimport { CancelToken } from './types';\nimport { validateSignAndSubmitTransactionResponse, validateSignMessageResponse } from './utils';\n\nconst API_VERSION = '0.2.0' as const;\nconst SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nconst SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\n\nasync function waitFor(milliseconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\n\nasync function withRetries<Response>(\n  requestFn: () => Promise<Response>,\n  onError: (err: any) => void,\n  retries: number = 1,\n) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\n\nexport interface SignRequestOptions {\n  cancelToken?: CancelToken;\n  networkName?: NetworkName;\n}\n\nexport type OnDisconnectListener = (address: string) => void;\nexport type OnDisconnectListenerCleanup = () => void;\n\nexport interface ACPairingClientConfig {\n  accessors?: DappStateAccessors;\n  axiosConfig?: CreateAxiosDefaults;\n  defaultNetworkName?: NetworkName;\n}\n\nexport class ACPairingClient {\n  protected readonly accessors: DappStateAccessors;\n  private readonly defaultNetworkName: NetworkName;\n  protected readonly axiosInstance: AxiosInstance;\n  private readonly initPromise?: Promise<void>;\n\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET,\n  }: ACPairingClientConfig = {}) {\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig,\n    });\n\n    const isClientSideRendering = typeof window !== 'undefined';\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : undefined;\n  }\n\n  private async getPairing(id: string) {\n    const response = await this.axiosInstance.get<GetPairingSerializedResponse>(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n\n  private async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === undefined) {\n      return;\n    }\n\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id,\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, undefined);\n    }\n  }\n\n  private async createSigningRequest<TRequestBody>(\n    pairing: DappPairingData,\n    type: string,\n    networkName: NetworkName,\n    requestBody: TRequestBody,\n  ) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody,\n        );\n\n        const response = await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n          `v1/pairing/${pairing.pairingId}/signing-request/`,\n          requestEnvelope,\n        );\n\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber,\n        });\n\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if (isAxiosError(err)) {\n          const errorMessage: string = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n          if (expectedSequenceNumber !== undefined) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      },\n    );\n  }\n\n  private async getSigningRequest(id: string) {\n    const response = await this.axiosInstance.get<GetSigningRequestSerializedResponse | undefined>(\n      `v1/signing-request/${id}/`,\n      {\n        validateStatus: (status) => status === 200 || status === 404,\n      },\n    );\n    return response.data?.data?.signingRequest;\n  }\n\n  protected async deletePairing(pairingId: string, secretKey: Ed25519SecretKey, publicKey: Ed25519PublicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      secretKey,\n      publicKey,\n      publicKey,\n      0, // ignored\n      {},\n      {},\n    );\n\n    await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 },\n    );\n  }\n\n  async cancelSigningRequest(pairing: DappPairingData, id: string) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {},\n    );\n\n    const response = await this.axiosInstance.patch<CancelSigningRequestSerializedResponse>(\n      `v1/signing-request/${id}/cancel/`,\n      requestEnvelope,\n    );\n\n    // TODO: auto-sync sequence number on error\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1,\n    });\n\n    return response.data.data.signingRequest;\n  }\n\n  private async signRequest<TRequestBody, TResponseBody>(\n    address: string,\n    type: SigningRequestTypes,\n    requestBody: TRequestBody,\n    { cancelToken, networkName }: SignRequestOptions = {},\n  ) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The requested account is not paired');\n    }\n\n    let signingRequest: SerializedDate<SigningRequestData>;\n\n    try {\n      signingRequest = await this.createSigningRequest<TRequestBody>(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody,\n      );\n\n      while (signingRequest.status === 'PENDING') {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          // TODO: send cancel request\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === '404') {\n        await this.accessors.update(address, undefined);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n\n    if (signingRequest.status !== 'APPROVED') {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n\n    const decrypted = decryptEnvelope<{}, TResponseBody & {}>(\n      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),\n      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),\n      signingRequest.responseEnvelope!,\n    );\n    return decrypted.privateMessage;\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({ publicKey, secretKey }: Ed25519KeyPair, finalizedPairing: SerializedDate<FinalizedPairingData>) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? undefined,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id,\n    });\n  }\n\n  async disconnect(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The specified account is not paired');\n    }\n\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n    );\n    await this.accessors.update(address, undefined);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n\n  async signMessage(address: string, args: SignMessageRequestArgs, options?: SignRequestOptions) {\n    const response = await this.signRequest<SignMessageRequestArgs, SignMessageResponseArgs>(\n      address,\n      SigningRequestTypes.SIGN_MESSAGE,\n      args,\n      options,\n    );\n    validateSignMessageResponse(response);\n    return response;\n  }\n\n  // region signTransaction\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithPayloadRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithPayloadResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithRawTxnRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithRawTxnResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest<\n      SerializedSignTransactionRequestArgs,\n      SerializedSignTransactionResponseArgs\n    >(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n\n  // endregion\n\n  async signAndSubmitTransaction(\n    address: string,\n    args: SignAndSubmitTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignAndSubmitTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest<\n        SerializedSignAndSubmitTransactionRequestArgs,\n        SignAndSubmitTransactionResponseArgs\n      >(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map<AccountInfo>(\n      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({\n        address: AccountAddress.from(accountAddress),\n        publicKey:\n          accountPublicKeyB64 !== undefined\n            ? deserializePublicKeyB64(accountPublicKeyB64)\n            : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64),\n      }),\n    );\n  }\n\n  // endregion\n\n  private readonly onDisconnectListeners = new Set<OnDisconnectListener>();\n\n  onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SigningRequestStatus } from '@identity-connect/api';\n\nexport class SignatureRequestError extends Error {\n  constructor(status: SigningRequestStatus) {\n    super(status);\n    this.name = 'SignatureRequestError';\n    Object.setPrototypeOf(this, SignatureRequestError.prototype);\n  }\n}\n\nexport class UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields: string[]) {\n    const message = `Missing the following fields: ${missingFields.join(', ')}`;\n    super(message);\n    this.name = 'UnexpectedSignatureResponseError';\n    Object.setPrototypeOf(this, UnexpectedSignatureResponseError.prototype);\n  }\n}\n\nexport class PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = 'PairingExpiredError';\n    Object.setPrototypeOf(this, PairingExpiredError.prototype);\n  }\n}\n\nexport class UnregisteredDappError extends Error {\n  constructor() {\n    super('Dapp ID is invalid or not associated with a registered Dapp.');\n    this.name = 'UnregisteredDappError';\n    Object.setPrototypeOf(this, UnregisteredDappError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface BaseDappPairingData {\n  accountAddress: string;\n  accountAlias?: string;\n  accountTransportEd25519PublicKeyB64: string;\n  currSequenceNumber: number;\n  dappEd25519PublicKeyB64: string;\n  dappEd25519SecretKeyB64: string;\n  dappWalletId?: string;\n  pairingId: string;\n}\n\n// Keeping this temporarily for backward compatibility\nexport interface PrevDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64: string;\n  accountPublicKeyB64?: undefined;\n}\n\nexport interface CurrDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64?: undefined;\n  accountPublicKeyB64: string;\n}\n\nexport type DappPairingData = PrevDappPairingData | CurrDappPairingData;\n\nexport type DappPairingDataMap = { [address: string]: DappPairingData };\n\nexport interface DappStateAccessors {\n  get: (address: string) => Promise<DappPairingData | undefined>;\n  getAll: () => Promise<DappPairingDataMap>;\n  update: (address: string, pairing?: DappPairingData) => Promise<void>;\n}\n\nexport const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = 'icDappPairings';\n\n/**\n * Default implementation of DappStateAccessors that uses the Window localStorage API.\n * This should work for most dapps.\n */\nexport const windowStateAccessors: DappStateAccessors = {\n  async get(address: string) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? (JSON.parse(serialized) as DappPairingDataMap) : {};\n  },\n  async update(address: string, pairing?: DappPairingData) {\n    const pairings = await this.getAll();\n    if (pairing === undefined) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  },\n};\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SignAndSubmitTransactionResponseArgs, SignMessageResponseArgs } from '@identity-connect/wallet-api';\nimport { UnexpectedSignatureResponseError } from './errors';\n\nconst SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS: (keyof SignMessageResponseArgs)[] = [\n  'address',\n  'application',\n  'chainId',\n  'fullMessage',\n  'message',\n  'nonce',\n  'prefix',\n  'signature',\n];\n\nexport function validateSignMessageResponse(response: SignMessageResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\nconst SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS: (keyof SignAndSubmitTransactionResponseArgs)[] = ['hash'];\n\nexport function validateSignAndSubmitTransactionResponse(response: SignAndSubmitTransactionResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field),\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { CreatePairingSerializedResponse, FinalizedPairingData, SerializedDate } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { UnregisteredDappError } from './errors';\nimport { ACPairingClient, ACPairingClientConfig } from './PairingClient';\nimport { openPrompt, waitForPromptResponse } from './prompt';\n\nexport interface ICDappClientConfig extends ACPairingClientConfig {\n  frontendBaseURL?: string;\n}\n\nexport class ICDappClient extends ACPairingClient {\n  private readonly frontendBaseURL: string;\n\n  constructor(\n    private readonly dappId: string,\n    { frontendBaseURL = DEFAULT_FRONTEND_URL, ...pairingClientConfig }: ICDappClientConfig = {},\n  ) {\n    super(pairingClientConfig);\n    this.frontendBaseURL = frontendBaseURL;\n  }\n\n  private async createPairingRequest(dappEd25519PublicKeyB64: string) {\n    try {\n      const response = await this.axiosInstance.post<CreatePairingSerializedResponse>('v1/pairing/', {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId,\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      // TODO: export typed errors from API\n      if (isAxiosError(err) && err.response?.data?.message === 'Dapp not found') {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = createEd25519KeyPair();\n    const dappEd25519PublicKeyB64 = encodeBase64(publicKey.key);\n\n    // Open the prompt without pairingId (for a snappier ux)\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n\n    let pairingId: string;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      // Close the prompt and have the dapp handle the error\n      promptWindow.close();\n      throw err;\n    }\n\n    // Update the prompt's URL as soon as a pairingId is available\n    url.searchParams.set('pairingId', pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse<SerializedDate<FinalizedPairingData>>(promptWindow);\n\n    if (promptResponse.status === 'dismissed') {\n      // Ignore the result. This is just a courtesy call, so if anything goes wrong\n      // the pairing will be removed during scheduled cleanup)\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return undefined;\n    }\n\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n\n    return finalizedPairing.account.accountAddress;\n  }\n\n  async offboard(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('This account is not paired');\n    }\n\n    const walletId = pairing.dappWalletId;\n    if (walletId === undefined) {\n      throw new Error('This account cannot be offboarded');\n    }\n\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse<{ offboarded: boolean }>(promptWindow);\n    if (response.status === 'approved' && response.args.offboarded) {\n      // If exported, disconnect the pairing to clean up\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport interface PromptApproval<TResponseArgs> {\n  args: TResponseArgs;\n  status: 'approved';\n}\n\nexport interface PromptDismissal {\n  status: 'dismissed';\n}\n\nexport type PromptResponse<TResponseArgs> = PromptApproval<TResponseArgs> | PromptDismissal;\n\nexport async function waitForPromptResponse<TResponseArgs>(promptWindow: Window) {\n  return new Promise<PromptResponse<TResponseArgs>>((resolve) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener('message', listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: 'approved',\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: 'dismissed',\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport { NetworkName } from '@identity-connect/api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\n\nexport interface ACKeylessClientConfig {\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n}\n\nexport class ACKeylessClient {\n  private readonly defaultNetworkName: NetworkName;\n\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n  }: ACKeylessClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL);\n  }\n\n  // region Public API\n\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async disconnect() {\n    const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n\n  async connect() {\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args) {\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args) {\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n"],"mappings":"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","names":["AccountAddress","NetworkName","encodeBase64","NetworkName","AccountAddress","encodeBase64","createEd25519KeyPair","encodeBase64","isAxiosError","isAxiosError","createEd25519KeyPair","encodeBase64","ConnectRequest","ConnectResponse","DisconnectRequest","GetConnectedAccountsRequest","GetConnectedAccountsResponse","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","WebWalletTransport","NetworkName","NetworkName","WebWalletTransport","GetConnectedAccountsRequest","GetConnectedAccountsResponse","DisconnectRequest","ConnectRequest","ConnectResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse"]}