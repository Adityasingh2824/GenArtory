var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
import { registerWallet } from "@aptos-labs/wallet-standard";

// src/AptosConnectWallet.ts
import {
  AccountAddress as AccountAddress2,
  Aptos,
  AptosConfig,
  Network,
  NetworkToNodeAPI
} from "@aptos-labs/ts-sdk";
import {
  AccountInfo as AccountInfo2,
  APTOS_CHAINS as APTOS_CHAINS2,
  AptosConnectNamespace,
  AptosDisconnectNamespace,
  AptosGetAccountNamespace,
  AptosGetNetworkNamespace,
  AptosOnAccountChangeNamespace,
  AptosOnNetworkChangeNamespace,
  AptosSignAndSubmitTransactionNamespace,
  AptosSignMessageNamespace,
  AptosSignTransactionNamespace,
  AptosWalletError,
  AptosWalletErrorCode,
  UserResponseStatus
} from "@aptos-labs/wallet-standard";
import { deserializePublicKeyB64, serializePublicKeyB64 } from "@identity-connect/crypto";
import { ACDappClient } from "@identity-connect/dapp-sdk";

// src/AptosConnectAccount.ts
import {
  AnyPublicKey,
  Ed25519PublicKey,
  MultiEd25519PublicKey,
  MultiKey,
  SigningScheme
} from "@aptos-labs/ts-sdk";
import { APTOS_CHAINS } from "@aptos-labs/wallet-standard";
var _address, _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    // region AptosWalletAccount
    this.chains = APTOS_CHAINS;
    this.features = [];
    // endregion
    // region PetraAccount
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof Ed25519PublicKey) {
      return SigningScheme.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof MultiEd25519PublicKey) {
      return SigningScheme.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof AnyPublicKey) {
      return SigningScheme.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof MultiKey) {
      return SigningScheme.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = new WeakMap();
_publicKey = new WeakMap();

// src/shared.ts
var walletName = "Continue with Google";
var walletUrl = "https://aptosconnect.app";
var walletIcon = (
  // eslint-disable-next-line max-len
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
);

// src/AptosConnectWallet.ts
function customAccountToStandardAccount({ address, name, publicKey }) {
  return new AccountInfo2({
    address,
    ansName: name,
    publicKey
  });
}
var _AptosConnectWallet = class _AptosConnectWallet {
  constructor({ network = Network.MAINNET, ...clientConfig }) {
    // endregion
    // region AptosWallet
    this.name = walletName;
    this.version = "1.0.0";
    this.icon = walletIcon;
    this.url = walletUrl;
    this.chains = APTOS_CHAINS2;
    this.client = new ACDappClient(clientConfig);
    if (!NetworkToNodeAPI[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new AptosConfig({ network });
    this.aptosClient = new Aptos(aptosConfig);
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(_AptosConnectWallet.connectedAccountStorageKey);
    if (!serialized) {
      return void 0;
    }
    const { address, publicKey } = JSON.parse(serialized);
    return serialized ? new AccountInfo2({
      address: AccountAddress2.from(address),
      publicKey: deserializePublicKeyB64(publicKey)
    }) : void 0;
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(_AptosConnectWallet.connectedAccountStorageKey, JSON.stringify(serialized));
    } else {
      localStorage.removeItem(_AptosConnectWallet.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  get features() {
    return {
      [AptosConnectNamespace]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [AptosDisconnectNamespace]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [AptosGetAccountNamespace]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [AptosGetNetworkNamespace]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [AptosOnAccountChangeNamespace]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [AptosOnNetworkChangeNamespace]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [AptosSignAndSubmitTransactionNamespace]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [AptosSignMessageNamespace]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [AptosSignTransactionNamespace]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.0.0"
      }
    };
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: UserResponseStatus.APPROVED };
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(response.args.account);
    _AptosConnectWallet.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: UserResponseStatus.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet.connectedAccount = void 0;
    }
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet;
    if (!connectedAccount) {
      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = NetworkToNodeAPI[network];
    return {
      chainId,
      name: network,
      url
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet;
    if (!connectedAccount) {
      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);
    }
    const { chainId } = await this.getNetwork();
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: "",
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: UserResponseStatus.APPROVED
    };
  }
  async signTransaction(transaction, _asFeePayer) {
    const { connectedAccount } = _AptosConnectWallet;
    if (!connectedAccount) {
      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);
    }
    const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
    const secondarySigners = transaction.secondarySignerAddresses?.map((address) => ({ address }));
    const response = await this.client.signTransaction({
      feePayer,
      secondarySigners,
      signerAddress: connectedAccount.address,
      transaction: transaction.rawTransaction
    });
    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }
    return {
      args: response.args.authenticator,
      status: UserResponseStatus.APPROVED
    };
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet;
    if (!connectedAccount) {
      throw new AptosWalletError(AptosWalletErrorCode.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }
    const txnResponse = await this.aptosClient.getTransactionByHash({
      transactionHash: response.args.txnHash
    });
    return {
      args: txnResponse,
      status: UserResponseStatus.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
// region connectedAccount
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;

// src/AptosConnectWalletPlugin.ts
import {
  AccountAddress as AccountAddress3,
  AccountAuthenticatorEd25519,
  AccountAuthenticatorSingleKey,
  Aptos as Aptos2,
  AptosConfig as AptosConfig2,
  MultiEd25519PublicKey as MultiEd25519PublicKey2,
  MultiKey as MultiKey2,
  Network as Network2,
  NetworkToNodeAPI as NetworkToNodeAPI2,
  SignedTransaction,
  TransactionAuthenticatorEd25519,
  TransactionAuthenticatorSingleSender,
  TransactionPayload
} from "@aptos-labs/ts-sdk";
import { AptosWalletError as AptosWalletError2, AptosWalletErrorCode as AptosWalletErrorCode2 } from "@aptos-labs/wallet-standard";
import { ACDappClient as ACDappClient2 } from "@identity-connect/dapp-sdk";
import { TxnBuilderTypes } from "aptos";

// src/conversion.ts
import { Deserializer } from "@aptos-labs/ts-sdk";
import { BCS } from "aptos";
function convertV1toV2(src, dst) {
  const serializedBytes = BCS.bcsToBytes(src);
  const deserializerV2 = new Deserializer(serializedBytes);
  return dst.deserialize(deserializerV2);
}
function convertPayloadInputFromV1ToV2(inputV1) {
  if ("multisig_address" in inputV1) {
    throw new Error("Multisig payload not supported");
  }
  if ("code" in inputV1) {
    throw new Error("Script payload not supported");
  }
  if ("function" in inputV1) {
    return {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
  }
  throw new Error("Unsupported payload type");
}

// src/AptosConnectWalletPlugin.ts
function customAccountToStandardAccount2({ address, name, publicKey }) {
  if (publicKey instanceof MultiEd25519PublicKey2 || publicKey instanceof MultiKey2) {
    throw new Error("Unsupported public key type");
  }
  return {
    address: address.toString(),
    ansName: name,
    publicKey: publicKey.toString()
  };
}
function accountAuthenticatorToTransactionAuthenticator(accountAuthenticator) {
  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {
    return new TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);
  }
  if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {
    if (accountAuthenticator.isEd25519()) {
      return new TransactionAuthenticatorEd25519(
        accountAuthenticator.public_key.publicKey,
        accountAuthenticator.signature.signature
      );
    }
    return new TransactionAuthenticatorSingleSender(accountAuthenticator);
  }
  throw new Error("Cannot convert account authenticator to a compatible transaction authenticator");
}
function unwrapUserResponse(response) {
  if (response.status === "dismissed") {
    throw new AptosWalletError2(0, "Rejected");
  }
  return response.args;
}
var _AptosConnectWalletPlugin = class _AptosConnectWalletPlugin {
  constructor({ network = Network2.MAINNET, ...clientConfig }) {
    // Hack to make this always available
    this.providerName = "open";
    this.version = "v2";
    this.name = walletName;
    this.url = walletUrl;
    this.icon = walletIcon;
    this.client = new ACDappClient2(clientConfig);
    if (!NetworkToNodeAPI2[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new AptosConfig2({ network });
    this.aptosClient = new Aptos2(aptosConfig);
  }
  static get connectedAccount() {
    const value = localStorage.getItem(_AptosConnectWalletPlugin.connectedAccountStorageKey);
    return value ? JSON.parse(value) : void 0;
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      localStorage.setItem(_AptosConnectWalletPlugin.connectedAccountStorageKey, JSON.stringify(value));
    } else {
      localStorage.removeItem(_AptosConnectWalletPlugin.connectedAccountStorageKey);
    }
  }
  // endregion
  async connect() {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (connectedAccount !== void 0) {
      return connectedAccount;
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    const newConnectedAccount = customAccountToStandardAccount2(response.args.account);
    _AptosConnectWalletPlugin.connectedAccount = newConnectedAccount;
    return newConnectedAccount;
  }
  async account() {
    const [firstAccount] = await this.client.getConnectedAccounts();
    if (firstAccount === void 0) {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    return customAccountToStandardAccount2(firstAccount);
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWalletPlugin.connectedAccount = void 0;
    }
  }
  async signAndSubmitTransaction(payloadV1InputOrGenerateTxnInput, optionsV1) {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (!connectedAccount) {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    let payload;
    let options;
    if ("data" in payloadV1InputOrGenerateTxnInput) {
      const { data: payloadV2Input, options: optionsV2 } = payloadV1InputOrGenerateTxnInput;
      payload = payloadV2Input;
      options = {
        expirationTimestamp: optionsV2?.expireTimestamp,
        gasUnitPrice: optionsV2?.gasUnitPrice,
        maxGasAmount: optionsV2?.maxGasAmount,
        network: this.aptosClient.config.network
      };
    } else {
      payload = convertPayloadInputFromV1ToV2(payloadV1InputOrGenerateTxnInput);
      options = {
        expirationTimestamp: optionsV1?.expirationTimestamp,
        gasUnitPrice: optionsV1?.gasUnitPrice ?? optionsV1?.gas_unit_price,
        maxGasAmount: optionsV1?.maxGasAmount ?? optionsV1?.max_gas_amount,
        network: this.aptosClient.config.network
      };
    }
    const response = await this.client.signAndSubmitTransaction({
      signerAddress: AccountAddress3.from(connectedAccount.address),
      ...options,
      payload
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signAndSubmitBCSTransaction(payloadV1, options) {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (!connectedAccount) {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    const payload = convertV1toV2(payloadV1, TransactionPayload);
    const response = await this.client.signAndSubmitTransaction({
      expirationTimestamp: options?.expirationTimestamp,
      gasUnitPrice: options?.gasUnitPrice ?? options?.gas_unit_price,
      maxGasAmount: options?.maxGasAmount ?? options?.max_gas_amount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: AccountAddress3.from(connectedAccount.address)
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signMessage(args) {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (!connectedAccount) {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    const chainId = await this.aptosClient.getChainId();
    const { message, nonce } = args;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: AccountAddress3.from(connectedAccount.address)
    });
    const { fullMessage, signature } = unwrapUserResponse(response);
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      fullMessage,
      signature: signature.toString(),
      ...extraResponseArgs
    };
  }
  async signTransaction(transactionOrPayload, optionsOrAsFeePayer) {
    const { connectedAccount } = _AptosConnectWalletPlugin;
    if (!connectedAccount) {
      throw new AptosWalletError2(AptosWalletErrorCode2.Unauthorized);
    }
    if ("rawTransaction" in transactionOrPayload) {
      const transaction = transactionOrPayload;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = transaction.secondarySignerAddresses?.map((address) => ({ address }));
      const response2 = await this.client.signTransaction({
        feePayer,
        secondarySigners,
        signerAddress: AccountAddress3.from(connectedAccount.address),
        transaction: transaction.rawTransaction
      });
      const { authenticator: authenticator2 } = unwrapUserResponse(response2);
      return authenticator2;
    }
    if (!(transactionOrPayload instanceof TxnBuilderTypes.TransactionPayload)) {
      throw new Error("Not supported");
    }
    const payload = convertV1toV2(transactionOrPayload, TransactionPayload);
    const options = optionsOrAsFeePayer;
    const sender = options?.sender ? {
      address: AccountAddress3.from(options.sender)
    } : void 0;
    const response = await this.client.signTransaction({
      expirationSecondsFromNow: options?.expirationSecondsFromNow,
      expirationTimestamp: options?.expirationTimestamp,
      gasUnitPrice: options?.gasUnitPrice ?? options?.gas_unit_price,
      maxGasAmount: options?.maxGasAmount ?? options?.max_gas_amount,
      network: this.aptosClient.config.network,
      payload,
      sender,
      sequenceNumber: options?.sequenceNumber,
      signerAddress: AccountAddress3.from(connectedAccount.address)
    });
    const { authenticator, rawTransaction } = unwrapUserResponse(response);
    if (rawTransaction === void 0) {
      throw new Error("The wallet did not return a raw transaction");
    }
    const txnAuthenticator = accountAuthenticatorToTransactionAuthenticator(authenticator);
    const signedTransaction = new SignedTransaction(rawTransaction, txnAuthenticator);
    return signedTransaction.bcsToBytes();
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  async network() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = NetworkToNodeAPI2[network];
    return {
      chainId: chainId.toString(),
      name: network,
      url
    };
  }
};
// region connectedAccount
_AptosConnectWalletPlugin.connectedAccountStorageKey = "AptosConnectWalletPlugin.connectedAccount";
var AptosConnectWalletPlugin = _AptosConnectWalletPlugin;

// src/index.ts
function registerAptosConnect(config = {}) {
  const walletPlugin = new AptosConnectWallet(config);
  registerWallet(walletPlugin);
}
export {
  AptosConnectAccount,
  AptosConnectWallet,
  AptosConnectWalletPlugin,
  registerAptosConnect
};
//# sourceMappingURL=index.mjs.map