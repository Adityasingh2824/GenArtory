// src/version.ts
var WALLET_ADAPTER_CORE_VERSION = "3.16.0";

// src/WalletCore.ts
import { TxnBuilderTypes as TxnBuilderTypes4, BCS as BCS2 } from "aptos";
import {
  Network as Network3,
  AccountAuthenticatorEd25519,
  Ed25519PublicKey,
  Ed25519Signature,
  AptosConfig as AptosConfig3,
  Aptos as Aptos3,
  generateRawTransaction,
  SimpleTransaction,
  NetworkToChainId
} from "@aptos-labs/ts-sdk";
import EventEmitter2 from "eventemitter3";
import {
  getAptosWallets,
  UserResponseStatus as UserResponseStatus2,
  isWalletWithRequiredFeatureSet
} from "@aptos-labs/wallet-standard";

// src/AIP62StandardWallets/sdkWallets.ts
import { TWallet } from "@atomrigslab/aptos-wallet-adapter";
var sdkWallets = [];
sdkWallets.push(new TWallet());
var sdkWallets_default = sdkWallets;

// src/constants.ts
var WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = /* @__PURE__ */ ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  "2": "testnet"
};

// src/error/index.ts
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
var WalletChangeNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletChangeNetworkError";
  }
};

// src/LegacyWalletPlugins/WalletCoreV1.ts
import { HexString } from "aptos";
import EventEmitter from "eventemitter3";
import { Buffer } from "buffer";
import {
  generateTransactionPayload as generateTransactionPayload2
} from "@aptos-labs/ts-sdk";
import nacl from "tweetnacl";

// src/LegacyWalletPlugins/conversion.ts
import {
  Network,
  TypeTag,
  generateTransactionPayload
} from "@aptos-labs/ts-sdk";
import { BCS, TxnBuilderTypes } from "aptos";
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name) {
    case "mainnet":
      return Network.MAINNET;
    case "testnet":
      return Network.TESTNET;
    case "devnet":
      return Network.DEVNET;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
function convertV2TransactionPayloadToV1BCSPayload(payload) {
  const deserializer = new BCS.Deserializer(payload.bcsToBytes());
  return TxnBuilderTypes.TransactionPayload.deserialize(deserializer);
}
function convertV2PayloadToV1JSONPayload(payload) {
  var _a, _b;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  } else if ("multisigAddress" in payload) {
    const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
      (typeTag) => {
        if (typeTag instanceof TypeTag) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "multisig_payload",
      multisig_address: payload.multisigAddress.toString(),
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  } else {
    const stringTypeTags = (_b = payload.typeArguments) == null ? void 0 : _b.map(
      (typeTag) => {
        if (typeTag instanceof TypeTag) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "entry_function_payload",
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  }
}
async function generateTransactionPayloadFromV1Input(aptosConfig, inputV1) {
  if ("function" in inputV1) {
    const inputV2 = {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
    return generateTransactionPayload({ ...inputV2, aptosConfig });
  }
  throw new Error("Payload type not supported");
}

// src/utils/scopePollingDetectionStrategy.ts
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}

// src/utils/localStorage.ts
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}

// src/utils/helpers.ts
import {
  Aptos,
  AptosConfig as AptosConfig2,
  Network as Network2,
  NetworkToNodeAPI,
  Serializable
} from "@aptos-labs/ts-sdk";
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return typeof error === "object" && "message" in error ? error.message : error;
}
var areBCSArguments = (args) => {
  if (args.length === 0)
    return false;
  return args.every(
    (arg) => arg instanceof Serializable
  );
};
var getAptosConfig = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  if (isAptosNetwork(networkInfo)) {
    return new AptosConfig2({
      network: convertNetwork(networkInfo)
    });
  }
  return new AptosConfig2({
    network: Network2.CUSTOM,
    fullnode: networkInfo.url
  });
};
var isAptosNetwork = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return NetworkToNodeAPI[networkInfo.name] !== void 0;
};
var fetchDevnetChainId = async () => {
  const aptos = new Aptos();
  return await aptos.getChainId();
};

// src/LegacyWalletPlugins/WalletCoreV1.ts
var WalletCoreV1 = class extends EventEmitter {
  async connect(wallet) {
    const account = await wallet.connect();
    return account;
  }
  async resolveSignAndSubmitTransaction(payloadData, network, wallet, transactionInput) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (areBCSArguments(payloadData.functionArguments)) {
      const aptosConfig = getAptosConfig(network);
      const newPayload = await generateTransactionPayload2({
        ...payloadData,
        aptosConfig
      });
      const oldTransactionPayload2 = convertV2TransactionPayloadToV1BCSPayload(newPayload);
      return await this.signAndSubmitBCSTransaction(
        oldTransactionPayload2,
        wallet,
        {
          max_gas_amount: ((_a = transactionInput.options) == null ? void 0 : _a.maxGasAmount) ? BigInt((_b = transactionInput.options) == null ? void 0 : _b.maxGasAmount) : void 0,
          gas_unit_price: ((_c = transactionInput.options) == null ? void 0 : _c.gasUnitPrice) ? BigInt((_d = transactionInput.options) == null ? void 0 : _d.gasUnitPrice) : void 0
        }
      );
    }
    const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);
    return await this.signAndSubmitTransaction(oldTransactionPayload, wallet, {
      max_gas_amount: ((_e = transactionInput.options) == null ? void 0 : _e.maxGasAmount) ? BigInt((_f = transactionInput.options) == null ? void 0 : _f.maxGasAmount) : void 0,
      gas_unit_price: ((_g = transactionInput.options) == null ? void 0 : _g.gasUnitPrice) ? BigInt((_h = transactionInput.options) == null ? void 0 : _h.gasUnitPrice) : void 0
    });
  }
  async signAndSubmitTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, wallet, options) {
    if (!("signAndSubmitBCSTransaction" in wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${wallet.name}`
      ).message;
    }
    try {
      const response = await wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet, account) {
    try {
      const response = await wallet.signMessage(message);
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      console.log("signMessageAndVerify signMessage response", response);
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n) => Array.from({ length: 8 }).map((_, i) => n >> i & 1)
            );
            const index = bits.map((_, i) => i).filter((i) => bits[i]);
            const publicKeys = account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i) => index.includes(i)
            );
            verified = true;
            for (let i = 0; i < signature.length; i++) {
              const isSigVerified = nacl.sign.detached.verify(
                Buffer.from(fullMessage),
                Buffer.from(signature[i], "hex"),
                Buffer.from(matchedPublicKeys[i], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          account.publicKey
        );
        const signature = new HexString(
          response.signature
        );
        verified = nacl.sign.detached.verify(
          Buffer.from(response.fullMessage),
          Buffer.from(signature.noPrefix(), "hex"),
          Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// src/LegacyWalletPlugins/types.ts
import { TxnBuilderTypes as TxnBuilderTypes3, Types as Types3 } from "aptos";

// src/AIP62StandardWallets/WalletStandard.ts
import {
  UserResponseStatus
} from "@aptos-labs/wallet-standard";
import {
  MultiEd25519Signature,
  MultiEd25519PublicKey
} from "@aptos-labs/ts-sdk";
var WalletStandardCore = class {
  async connect(wallet) {
    const response = await wallet.connect();
    if (response.status === UserResponseStatus.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signAndSubmitTransaction(transactionInput, aptos, account, wallet) {
    try {
      const transaction = await aptos.transaction.build.simple({
        sender: account.address.toString(),
        data: transactionInput.data,
        options: transactionInput.options
      });
      const response = await wallet.signAndSubmitTransaction(
        transaction
      );
      if (response.status === UserResponseStatus.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, asFeePayer) {
    const response = await wallet.signTransaction(
      transaction,
      asFeePayer
    );
    if (response.status === UserResponseStatus.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signMessage(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      if (response.status === UserResponseStatus.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      const account = await wallet.account();
      if (response.status === UserResponseStatus.REJECTED) {
        throw new WalletConnectionError("Failed to sign a message").message;
      }
      let verified = false;
      if (response.args.signature instanceof MultiEd25519Signature) {
        if (!(account.publicKey instanceof MultiEd25519PublicKey)) {
          throw new WalletSignMessageAndVerifyError(
            "Public key and Signature type mismatch"
          ).message;
        }
        const { fullMessage, signature } = response.args;
        const bitmap = signature.bitmap;
        if (bitmap) {
          const minKeysRequired = account.publicKey.threshold;
          if (signature.signatures.length < minKeysRequired) {
            verified = false;
          } else {
            verified = account.publicKey.verifySignature({
              message: new TextEncoder().encode(fullMessage),
              signature
            });
          }
        }
      } else {
        verified = account.publicKey.verifySignature({
          message: new TextEncoder().encode(response.args.fullMessage),
          signature: response.args.signature
        });
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// src/ga/index.ts
var GA4 = class {
  constructor() {
    this.aptosGAID = "G-GNVVWBL3J9";
    this.injectGA(this.aptosGAID);
  }
  gtag(a, b, c) {
    let dataLayer = window.dataLayer || [];
    dataLayer.push(arguments);
  }
  injectGA(gaID) {
    if (typeof window === "undefined")
      return;
    if (!gaID)
      return;
    const head = document.getElementsByTagName("head")[0];
    var myScript = document.createElement("script");
    myScript.setAttribute(
      "src",
      `https://www.googletagmanager.com/gtag/js?id=${gaID}`
    );
    const that = this;
    myScript.onload = function() {
      that.gtag("js", new Date());
      that.gtag("config", `${gaID}`, {
        send_page_view: false
      });
    };
    head.insertBefore(myScript, head.children[1]);
  }
};

// src/AIP62StandardWallets/registry.ts
var aptosStandardSupportedWalletList = [
  {
    name: "Nightly",
    url: "https://chromewebstore.google.com/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected" /* NotDetected */,
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWbSURBVHgB7Z09c9NYFIaPlFSpUqQNK6rQhbSkWJghLZP9BesxfwAqytg1xe7+AY+3go5ACzObBkpwSqrVQkuRCiqkva8UZW1je22wpHPveZ8ZRU6wwwznueee+6FLJCuSdzrb7nZTNjaOJc9/ctdNiaJESPPkeeq+phLH5/L162k0HJ7JikTLvtEFPnFBf+D+0l/dt9tCNJK6xnjmZOg7GdJlPvC/AhQtPo5P3MsHQvwhiobLiLBQABf82y74z4Qt3ldSybKHToLTeW+I5/1B3u2euOD/JQy+zyRowEUs5zAzA1x+oCckJHrRYNCf/uE3AjD4QfONBBMC5PfvY2j3TEi4ZNmd8eHilQDFMK/s8xMhIXPhJLjuJLjAN/8VgRsbPWHwLbAtm5tXRWGRAS5b/99C7FBmgbTMAGXrJ5aIomJir8wA3S5afyLEEkUtEBezfQy+RYpFvdilgmMhNnGxRw2wL8QqScy1fMNE0T4yQCLEKkksxDQUwDj2BNjbK69pdndn/zxwNsUCCOyNGyJ374psbYkMBiLv30++59o1kW5X5NMnkdFI5OXL8nXghCsAAn10NL/Fz2NnpxQFFyR5/bq8BypDWAIg6AcHIoeH60nn4/K8e1deECIgwhAAQULQEXxIUAf43bju3ZvMDJ7jrwDT/XpToIvABeECqBf8EuB7+/W6CKBe0C/Auvv1uvC0XtArQBP9el14VC/oEqCtfr0uPKgX2hdAW79eF0rrhfYFQPCRKi1RyY4ZyZYF4GKQcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcShAm3z+LG1DAdqEAhjn40dpGwrQFtgIwgxgGAWtH1CAtsC2cQVQgLZQsk2cArSBoqeHKEAbKHpiiAI0DVq+kv4fUICmQetXMPyroABNgtb/5o1oggI0icJzBChAUyDwr16JNihAUzx+LBqhAE3w5InaU0MoQN08f64y9VdQgDrBkO/FC9EMBagLBB/P/yvHxlGxTYPh3tOn4gMUYN2g4FPc509DAdYFqvxZh1ArhwKsg6rSVzTHvywU4EeoqnyPTxKnAKuCVo4iD4s6ARwhTwGWoTrk8e3bIE4IH4cCVCDI1U6dL1/K73Eh4B727ctCASoQ6MBa9zJwJtA4FMA4FMA4FMA4FMA4FMA4FMA4FMA47Qtg4P/n1Uz7AgQ8zeoD7Qug5KQMq+joApgFWkNHEWhwEUYLFMA4OgRQdGCCNXQIUG28II2jZyKIWaAV9Aig7OgUK+gRAMH36ImaUNC1FoDt1swCjaJLAAQfT9mQxtC3GohugCOCxtC5HIyHLNkVNIJOATAv4Mnz9b6jd0MIhoWsB2pH944gPHmLkQGpDf1bwtAVUILa8GNPICRgd1AL/mwKRXfA0cHa8WtXMArDfp8bSdeIf9vCEfxHj8psQBF+GH/PB0A2wIzhrVsih4ciOztCVsfvAyKQAVAbYPr44EDk6Ehkd1fI8oRxQggKQ2QEXMgEe3ulELhvbQmZT3hHxFRn+1Tn/UAAZAWIUXUTHz4IKQn/jCBkB6Pn/ywDHw41DgUwDgRIhVgljSWKzoXYJM+dAFmWCrHKeewsOBViExd71AAjd10IsUYaDYdnsfty4Uz4U4g1zvClHAbm+e9CbJFlfdwKAVwWSJ0EfwixwrCIuYxPBOV5T1gLWCCtWj+4EqCoBbLsFyFhk2UPq9YPJqaCURW6W19IqPRdjCeG/dGsd+Xdbs/dToSERD8aDHrTP4zmvZsSBMXM4INo0afyTudY4vg39zIR4iNFXXfZtc9k4XJw0V9k2R1OFHkIhvVZdn1R8MHCDDDx+zqdxK0c9tz1szAjaKWc1XUTe+OV/iKWFmAcJ8NtJ8Kxe7kvkCGKEiHN45Zz3b/9yN3/uVzUGxXD+RX4F56985hsqA6SAAAAAElFTkSuQmCC",
    readyState: "NotDetected" /* NotDetected */,
    isAIP62Standard: true
  }
];

// src/WalletCore.ts
var WalletCore = class extends EventEmitter2 {
  constructor(plugins, optInWallets) {
    super();
    this._wallets = [];
    this._optInWallets = [];
    this._standard_wallets = [];
    this._all_wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this.walletCoreV1 = new WalletCoreV1();
    this.walletStandardCore = new WalletStandardCore();
    this._connecting = false;
    this._connected = false;
    this.ga4 = new GA4();
    this.standardizeStandardWalletToPluginWalletType = (standardWallet) => {
      var _a, _b, _c;
      let standardWalletConvertedToWallet = {
        name: standardWallet.name,
        url: standardWallet.url,
        icon: standardWallet.icon,
        provider: standardWallet,
        connect: standardWallet.features["aptos:connect"].connect,
        disconnect: standardWallet.features["aptos:disconnect"].disconnect,
        network: standardWallet.features["aptos:network"].network,
        account: standardWallet.features["aptos:account"].account,
        signAndSubmitTransaction: (_a = standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.signAndSubmitTransaction,
        signMessage: standardWallet.features["aptos:signMessage"].signMessage,
        onAccountChange: standardWallet.features["aptos:onAccountChange"].onAccountChange,
        onNetworkChange: standardWallet.features["aptos:onNetworkChange"].onNetworkChange,
        signTransaction: standardWallet.features["aptos:signTransaction"].signTransaction,
        openInMobileApp: (_b = standardWallet.features["aptos:openInMobileApp"]) == null ? void 0 : _b.openInMobileApp,
        changeNetwork: (_c = standardWallet.features["aptos:changeNetwork"]) == null ? void 0 : _c.changeNetwork,
        readyState: "Installed" /* Installed */,
        isAIP62Standard: true
      };
      this._all_wallets = this._all_wallets.filter(
        (item) => item.name !== standardWalletConvertedToWallet.name
      );
      this._all_wallets.push(standardWalletConvertedToWallet);
      this.emit("standardWalletsAdded", standardWalletConvertedToWallet);
    };
    this._wallets = plugins;
    this._optInWallets = optInWallets;
    this.scopePollingDetectionStrategy();
    this.fetchAptosWallets();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      this._all_wallets.push(wallet);
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" /* Unsupported */ : "NotDetected" /* NotDetected */;
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed" /* Installed */;
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  fetchAptosWallets() {
    let { aptosWallets, on } = getAptosWallets();
    this.setWallets(aptosWallets);
    if (typeof window === "undefined")
      return;
    const that = this;
    const removeRegisterListener = on("register", function() {
      let { aptosWallets: aptosWallets2 } = getAptosWallets();
      that.setWallets(aptosWallets2);
    });
    const removeUnregisterListener = on("unregister", function() {
      let { aptosWallets: aptosWallets2 } = getAptosWallets();
      that.setWallets(aptosWallets2);
    });
  }
  appendNotDetectedStandardSupportedWallets(aptosStandardWallets) {
    aptosStandardSupportedWalletList.map((supportedWallet) => {
      if (this.excludeWallet(supportedWallet.name)) {
        return;
      }
      const existingWalletIndex = aptosStandardWallets.findIndex(
        (wallet) => wallet.name == supportedWallet.name
      );
      if (existingWalletIndex === -1) {
        this._all_wallets.push(supportedWallet);
        this.emit("standardWalletsAdded", supportedWallet);
      }
    });
  }
  setWallets(extensionwWallets) {
    const aptosStandardWallets = [];
    [...sdkWallets_default, ...extensionwWallets].map((wallet) => {
      if (this.excludeWallet(wallet.name)) {
        return;
      }
      const isValid = isWalletWithRequiredFeatureSet(wallet);
      if (isValid) {
        wallet.readyState = "Installed" /* Installed */;
        aptosStandardWallets.push(wallet);
        this.standardizeStandardWalletToPluginWalletType(wallet);
      }
    });
    this._standard_wallets = aptosStandardWallets;
    this.appendNotDetectedStandardSupportedWallets(this._standard_wallets);
  }
  excludeWallet(walletName) {
    if (this._optInWallets.length > 0 && !this._optInWallets.includes(walletName)) {
      return true;
    }
    return false;
  }
  recordEvent(eventName, additionalInfo) {
    var _a, _b, _c;
    this.ga4.gtag("event", `wallet_adapter_${eventName}`, {
      wallet: (_a = this._wallet) == null ? void 0 : _a.name,
      network: (_b = this._network) == null ? void 0 : _b.name,
      network_url: (_c = this._network) == null ? void 0 : _c.url,
      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
      send_to: "G-GNVVWBL3J9",
      ...additionalInfo
    });
  }
  ensureWalletExists(wallet) {
    if (!wallet) {
      throw new WalletNotConnectedError().name;
    }
    if (!(wallet.readyState === "Loadable" /* Loadable */ || wallet.readyState === "Installed" /* Installed */))
      throw new WalletNotReadyError("Wallet is not set").name;
  }
  ensureAccountExists(account) {
    if (!account) {
      throw new WalletAccountError("Account is not set").name;
    }
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" /* Loadable */ || this._wallet.readyState === "Installed" /* Installed */))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isAptosNetwork(this._network)) {
        this._account.ansName = void 0;
        return;
      }
      const aptosConfig = new AptosConfig3({
        network: convertNetwork(this._network)
      });
      const aptos = new Aptos3(aptosConfig);
      const name = await aptos.ans.getPrimaryName({
        address: this._account.address
      });
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    var _a;
    if (account === null) {
      this._account = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      if ("status" in account) {
        const connectStandardAccount = account;
        if (connectStandardAccount.status === UserResponseStatus2.REJECTED) {
          this._connecting = false;
          throw new WalletConnectionError("User has rejected the request").message;
        }
        this._account = {
          address: connectStandardAccount.args.address.toString(),
          publicKey: connectStandardAccount.args.publicKey.toString(),
          ansName: connectStandardAccount.args.ansName
        };
        return;
      } else {
        const standardAccount = account;
        this._account = {
          address: standardAccount.address.toString(),
          publicKey: standardAccount.publicKey.toString(),
          ansName: standardAccount.ansName
        };
        return;
      }
    }
    this._account = { ...account };
    return;
  }
  setNetwork(network) {
    var _a, _b, _c;
    if (network === null) {
      this._network = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      const standardizeNetwork = network;
      this.recordEvent("network_change", {
        from: (_b = this._network) == null ? void 0 : _b.name,
        to: standardizeNetwork.name
      });
      this._network = {
        name: standardizeNetwork.name.toLowerCase(),
        chainId: standardizeNetwork.chainId.toString(),
        url: standardizeNetwork.url
      };
      return;
    }
    this.recordEvent("network_change", {
      from: (_c = this._network) == null ? void 0 : _c.name,
      to: network.name
    });
    this._network = {
      ...network,
      name: network.name.toLowerCase()
    };
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._all_wallets;
  }
  get pluginWallets() {
    return this._wallets;
  }
  get standardWallets() {
    return this._standard_wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName) {
    var _a;
    const allDetectedWallets = this._all_wallets;
    const selectedWallet = allDetectedWallets.find(
      (wallet) => wallet.name === walletName
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (((_a = this._wallet) == null ? void 0 : _a.name) === walletName)
        throw new WalletConnectionError(
          `${walletName} wallet is already connected`
        ).message;
    }
    if (isRedirectable() && selectedWallet.readyState !== "Installed" /* Installed */) {
      if (selectedWallet.isAIP62Standard && selectedWallet.openInMobileApp) {
        selectedWallet.openInMobileApp();
        return;
      }
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
      return;
    }
    if (selectedWallet.readyState !== "Installed" /* Installed */ && selectedWallet.readyState !== "Loadable" /* Loadable */) {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      let account;
      if (selectedWallet.isAIP62Standard) {
        account = await this.walletStandardCore.connect(selectedWallet);
      } else {
        account = await this.walletCoreV1.connect(selectedWallet);
      }
      this.setAccount(account);
      const network = await selectedWallet.network();
      this.setNetwork(network);
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.recordEvent("wallet_connect");
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = generalizedErrorMessage(error);
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.disconnect();
      this.clearData();
      this.recordEvent("wallet_disconnect");
      this.emit("disconnect");
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transactionInput) {
    try {
      if ("function" in transactionInput.data) {
        if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
          throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
        }
      }
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_and_submit_transaction");
      const payloadData = transactionInput.data;
      const aptosConfig = getAptosConfig(this._network);
      const aptos = new Aptos3(aptosConfig);
      if (this._wallet.signAndSubmitTransaction) {
        if (this._wallet.isAIP62Standard) {
          const { hash, ...output } = await this.walletStandardCore.signAndSubmitTransaction(
            transactionInput,
            aptos,
            this._account,
            this._wallet
          );
          return { hash, output };
        } else {
          const { hash, ...output } = await this.walletCoreV1.resolveSignAndSubmitTransaction(
            payloadData,
            this._network,
            this._wallet,
            transactionInput
          );
          return { hash, output };
        }
      }
      const transaction = await aptos.transaction.build.simple({
        sender: this._account.address,
        data: transactionInput.data,
        options: transactionInput.options
      });
      const senderAuthenticator = await this.signTransaction(transaction);
      const response = await this.submitTransaction({
        transaction,
        senderAuthenticator
      });
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrPayload, asFeePayer, options) {
    var _a, _b, _c, _d;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_transaction");
      if (this._wallet.signTransaction) {
        if (this._wallet.isAIP62Standard) {
          if ("rawTransaction" in transactionOrPayload) {
            return await this.walletStandardCore.signTransaction(
              transactionOrPayload,
              this._wallet,
              asFeePayer
            );
          } else {
            const aptosConfig = getAptosConfig(this._network);
            this.ensureAccountExists(this._account);
            const sender = this._account.address;
            const payload = await generateTransactionPayloadFromV1Input(
              aptosConfig,
              transactionOrPayload
            );
            const optionsV1 = options;
            const optionsV2 = {
              accountSequenceNumber: optionsV1 == null ? void 0 : optionsV1.sequenceNumber,
              expireTimestamp: (_a = optionsV1 == null ? void 0 : optionsV1.expireTimestamp) != null ? _a : optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
              gasUnitPrice: (_b = optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) != null ? _b : optionsV1 == null ? void 0 : optionsV1.gas_unit_price,
              maxGasAmount: (_c = optionsV1 == null ? void 0 : optionsV1.maxGasAmount) != null ? _c : optionsV1 == null ? void 0 : optionsV1.max_gas_amount
            };
            const rawTransaction = await generateRawTransaction({
              aptosConfig,
              payload,
              sender,
              options: optionsV2
            });
            return await this.walletStandardCore.signTransaction(
              new SimpleTransaction(rawTransaction),
              this._wallet,
              false
            );
          }
        }
        if ("rawTransaction" in transactionOrPayload) {
          const accountAuthenticator = await this._wallet.signTransaction(
            transactionOrPayload,
            asFeePayer
          );
          return accountAuthenticator;
        } else {
          const response = await this.walletCoreV1.signTransaction(
            transactionOrPayload,
            this._wallet,
            {
              max_gas_amount: (options == null ? void 0 : options.maxGasAmount) ? BigInt(options == null ? void 0 : options.maxGasAmount) : void 0,
              gas_unit_price: (options == null ? void 0 : options.gasUnitPrice) ? BigInt(options == null ? void 0 : options.gasUnitPrice) : void 0
            }
          );
          if (!response) {
            throw new Error("error");
          }
          const deserializer1 = new BCS2.Deserializer(response);
          const deserializedSignature = TxnBuilderTypes4.SignedTransaction.deserialize(deserializer1);
          const transactionAuthenticator = deserializedSignature.authenticator;
          const publicKey = transactionAuthenticator.public_key.value;
          const signature = transactionAuthenticator.signature.value;
          const accountAuthenticator = new AccountAuthenticatorEd25519(
            new Ed25519PublicKey(publicKey),
            new Ed25519Signature(signature)
          );
          return accountAuthenticator;
        }
      }
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_d = this.wallet) == null ? void 0 : _d.name}`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_message");
      if (this._wallet.isAIP62Standard) {
        return await this.walletStandardCore.signMessage(message, this._wallet);
      }
      const response = await this._wallet.signMessage(message);
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transaction) {
    try {
      this.ensureWalletExists(this._wallet);
      const { additionalSignersAuthenticators } = transaction;
      const transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
      this.recordEvent("submit_transaction", {
        transaction_type: transactionType
      });
      if (this._wallet.submitTransaction) {
        const pendingTransaction = await this._wallet.submitTransaction(transaction);
        return pendingTransaction;
      }
      const aptosConfig = new AptosConfig3({
        network: convertNetwork(this.network)
      });
      const aptos = new Aptos3(aptosConfig);
      if (additionalSignersAuthenticators !== void 0) {
        const multiAgentTxn = {
          ...transaction,
          additionalSignersAuthenticators
        };
        return aptos.transaction.submit.multiAgent(multiAgentTxn);
      } else {
        return aptos.transaction.submit.simple(transaction);
      }
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onAccountChange(
        async (data) => {
          this.setAccount(data);
          await this.setAnsName();
          this.recordEvent("account_change");
          this.emit("accountChange", this._account);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onNetworkChange(
        async (data) => {
          this.setNetwork(data);
          await this.setAnsName();
          this.emit("networkChange", this._network);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async changeNetwork(network) {
    var _a;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("change_network_request", {
        from: (_a = this._network) == null ? void 0 : _a.name,
        to: network
      });
      const chainId = network === Network3.DEVNET ? await fetchDevnetChainId() : NetworkToChainId[network];
      if (this._wallet.changeNetwork) {
        const networkInfo = {
          name: network,
          chainId
        };
        const response = await this._wallet.changeNetwork(networkInfo);
        if (response.status === UserResponseStatus2.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response.args;
      }
      throw new WalletChangeNetworkError(
        `${this._wallet.name} does not support changing network request`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletChangeNetworkError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_message_and_verify");
      if (this._wallet.isAIP62Standard) {
        return this.walletStandardCore.signMessageAndVerify(
          message,
          this._wallet
        );
      }
      return await this.walletCoreV1.signMessageAndVerify(
        message,
        this._wallet,
        this._account
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};

// src/index.ts
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}
export {
  ChainIdToAnsSupportedNetworkMap,
  NetworkName,
  TxnBuilderTypes3 as TxnBuilderTypes,
  Types3 as Types,
  WalletCore,
  WalletCoreV1,
  WalletReadyState,
  WalletStandardCore,
  areBCSArguments,
  convertNetwork,
  convertV2PayloadToV1JSONPayload,
  convertV2TransactionPayloadToV1BCSPayload,
  fetchDevnetChainId,
  generalizedErrorMessage,
  generateTransactionPayloadFromV1Input,
  getAptosConfig,
  getLocalStorage,
  isAptosNetwork,
  isInAppBrowser,
  isMobile,
  isRedirectable,
  removeLocalStorage,
  scopePollingDetectionStrategy,
  setLocalStorage
};
//# sourceMappingURL=index.mjs.map