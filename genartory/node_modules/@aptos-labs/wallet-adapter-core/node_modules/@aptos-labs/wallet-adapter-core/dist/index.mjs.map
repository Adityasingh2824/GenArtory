{"version":3,"sources":["../src/version.ts","../src/WalletCore.ts","../src/AIP62StandardWallets/sdkWallets.ts","../src/constants.ts","../src/error/index.ts","../src/LegacyWalletPlugins/WalletCoreV1.ts","../src/LegacyWalletPlugins/conversion.ts","../src/utils/scopePollingDetectionStrategy.ts","../src/utils/localStorage.ts","../src/utils/helpers.ts","../src/LegacyWalletPlugins/types.ts","../src/AIP62StandardWallets/WalletStandard.ts","../src/ga/index.ts","../src/AIP62StandardWallets/registry.ts","../src/index.ts"],"sourcesContent":["export const WALLET_ADAPTER_CORE_VERSION = \"3.16.0\";\n","import { TxnBuilderTypes, Types, BCS } from \"aptos\";\nimport {\n  Network,\n  AnyRawTransaction,\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  Ed25519PublicKey,\n  InputGenerateTransactionOptions,\n  Ed25519Signature,\n  AptosConfig,\n  InputSubmitTransactionData,\n  PendingTransactionResponse,\n  Aptos,\n  generateRawTransaction,\n  SimpleTransaction,\n  NetworkToChainId,\n} from \"@aptos-labs/ts-sdk\";\nimport EventEmitter from \"eventemitter3\";\nimport {\n  AccountInfo as StandardAccountInfo,\n  AptosChangeNetworkOutput,\n  AptosWallet,\n  getAptosWallets,\n  NetworkInfo as StandardNetworkInfo,\n  UserResponse,\n  UserResponseStatus,\n  isWalletWithRequiredFeatureSet,\n} from \"@aptos-labs/wallet-standard\";\n\nimport SDKWallets from \"./AIP62StandardWallets/sdkWallets\";\nimport { ChainIdToAnsSupportedNetworkMap, WalletReadyState } from \"./constants\";\nimport {\n  WalletAccountChangeError,\n  WalletAccountError,\n  WalletChangeNetworkError,\n  WalletConnectionError,\n  WalletDisconnectionError,\n  WalletGetNetworkError,\n  WalletNetworkChangeError,\n  WalletNotConnectedError,\n  WalletNotReadyError,\n  WalletNotSelectedError,\n  WalletNotSupportedMethod,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageAndVerifyError,\n  WalletSignMessageError,\n  WalletSignTransactionError,\n} from \"./error\";\nimport {\n  AccountInfo,\n  InputTransactionData,\n  NetworkInfo,\n  SignMessagePayload,\n  SignMessageResponse,\n  Wallet,\n  WalletCoreEvents,\n  WalletInfo,\n  WalletName,\n  WalletCoreV1,\n  CompatibleTransactionOptions,\n  convertNetwork,\n  generateTransactionPayloadFromV1Input,\n} from \"./LegacyWalletPlugins\";\nimport {\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getAptosConfig,\n  isAptosNetwork,\n  isRedirectable,\n  removeLocalStorage,\n  scopePollingDetectionStrategy,\n  setLocalStorage,\n} from \"./utils\";\nimport {\n  AptosStandardWallet,\n  WalletStandardCore,\n  AptosStandardSupportedWallet,\n  AvailableWallets,\n} from \"./AIP62StandardWallets\";\nimport { GA4 } from \"./ga\";\nimport { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\nimport { aptosStandardSupportedWalletList } from \"./AIP62StandardWallets/registry\";\n\nexport type IAptosWallet = AptosStandardWallet & Wallet;\n\nexport class WalletCore extends EventEmitter<WalletCoreEvents> {\n  // Private array to hold legacy wallet adapter plugins\n  private _wallets: ReadonlyArray<Wallet> = [];\n\n  // Private array that holds all the Wallets a dapp decided to opt-in to\n  private _optInWallets: ReadonlyArray<AvailableWallets> = [];\n\n  // Private array to hold compatible AIP-62 standard wallets\n  private _standard_wallets: ReadonlyArray<AptosStandardWallet> = [];\n\n  // Private array to hold all wallets (legacy wallet adapter plugins AND compatible AIP-62 standard wallets)\n  // while providing support for legacy and new wallet standard\n  private _all_wallets: Array<Wallet | AptosStandardSupportedWallet> = [];\n\n  // Current connected wallet\n  private _wallet: Wallet | null = null;\n\n  // Current connected account\n  private _account: AccountInfo | null = null;\n\n  // Current connected network\n  private _network: NetworkInfo | null = null;\n\n  // WalletCoreV1 property to interact with wallet adapter v1 (legacy wallet adapter plugins) functionality\n  private readonly walletCoreV1: WalletCoreV1 = new WalletCoreV1();\n\n  // WalletStandardCore property to interact with wallet adapter v2 (compatible AIP-62 standard wallets) functionality\n  private readonly walletStandardCore: WalletStandardCore =\n    new WalletStandardCore();\n\n  // Indicates whether the dapp is currently connecting with a wallet\n  private _connecting: boolean = false;\n\n  // Indicates whether the dapp is connected with a wallet\n  private _connected: boolean = false;\n\n  // Google Analytics 4 module\n  private readonly ga4: GA4 = new GA4();\n\n  /**\n   * Core functionality constructor.\n   * For legacy wallet adapter v1 support we expect the dapp to pass in wallet plugins,\n   * since AIP-62 standard support this is optional for dapps.\n   *\n   * @param plugins legacy wallet adapter v1 wallet plugins\n   */\n  constructor(\n    plugins: ReadonlyArray<Wallet>,\n    optInWallets: ReadonlyArray<AvailableWallets>\n  ) {\n    super();\n    this._wallets = plugins;\n    this._optInWallets = optInWallets;\n    // Strategy to detect legacy wallet adapter v1 wallet plugins\n    this.scopePollingDetectionStrategy();\n    // Strategy to detect AIP-62 standard compatible wallets (extension + SDK wallets)\n    this.fetchAptosWallets();\n  }\n\n  private scopePollingDetectionStrategy() {\n    this._wallets?.forEach((wallet: Wallet) => {\n      this._all_wallets.push(wallet);\n      if (!wallet.readyState) {\n        wallet.readyState =\n          typeof window === \"undefined\" || typeof document === \"undefined\"\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n      }\n      if (typeof window !== \"undefined\") {\n        scopePollingDetectionStrategy(() => {\n          const providerName = wallet.providerName || wallet.name.toLowerCase();\n          if (Object.keys(window).includes(providerName)) {\n            wallet.readyState = WalletReadyState.Installed;\n            wallet.provider = window[providerName as any];\n            this.emit(\"readyStateChange\", wallet);\n            return true;\n          }\n          return false;\n        });\n      }\n    });\n  }\n\n  private fetchAptosWallets() {\n    let { aptosWallets, on } = getAptosWallets();\n    this.setWallets(aptosWallets);\n\n    if (typeof window === \"undefined\") return;\n    // Adds an event listener for new wallets that get registered after the dapp has been loaded,\n    // receiving an unsubscribe function, which it can later use to remove the listener\n    const that = this;\n    const removeRegisterListener = on(\"register\", function () {\n      let { aptosWallets } = getAptosWallets();\n      that.setWallets(aptosWallets);\n    });\n\n    const removeUnregisterListener = on(\"unregister\", function () {\n      let { aptosWallets } = getAptosWallets();\n      that.setWallets(aptosWallets);\n    });\n  }\n\n  // Append wallets from wallet standard support registry to the `all_wallets` array\n  private appendNotDetectedStandardSupportedWallets(\n    aptosStandardWallets: ReadonlyArray<AptosStandardWallet>\n  ) {\n    aptosStandardSupportedWalletList.map((supportedWallet) => {\n      if (this.excludeWallet(supportedWallet.name)) {\n        return;\n      }\n      const existingWalletIndex = aptosStandardWallets.findIndex(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n\n      // If wallet does not exist, append it from the supported wallets list\n      if (existingWalletIndex === -1) {\n        this._all_wallets.push(supportedWallet);\n        this.emit(\"standardWalletsAdded\", supportedWallet);\n      }\n    });\n  }\n\n  /**\n   * Set potential Standard compatible SDK + extension wallets\n   *\n   * Loop over local SDK and Extensions wallets\n   * 1) check it is Standard compatible\n   * 2) Update their readyState to Installed (for a future UI detection)\n   * 3) push the wallet into a local wallets array\n   * 4) standardize each wallet to the Wallet Plugin type interface for legacy compatibility\n   *\n   * @param extensionwWallets\n   */\n  private setWallets(extensionwWallets: readonly AptosWallet[]) {\n    const aptosStandardWallets: AptosStandardWallet[] = [];\n\n    [...SDKWallets, ...extensionwWallets].map((wallet: AptosStandardWallet) => {\n      if (this.excludeWallet(wallet.name)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        wallet.readyState = WalletReadyState.Installed;\n        aptosStandardWallets.push(wallet);\n        this.standardizeStandardWalletToPluginWalletType(wallet);\n      }\n    });\n\n    this._standard_wallets = aptosStandardWallets;\n    // Append AIP-62 compatible wallets that are not detected on the user machine\n    this.appendNotDetectedStandardSupportedWallets(this._standard_wallets);\n  }\n\n  /**\n   * A function that excludes a wallet the dapp doesnt want to include\n   *\n   * @param walletName\n   * @returns\n   */\n  excludeWallet(walletName: string): boolean {\n    // If _optInWallets is not empty, and does not include the provided wallet,\n    // return true to exclude the wallet, otherwise return false\n    if (\n      this._optInWallets.length > 0 &&\n      !this._optInWallets.includes(walletName as AvailableWallets)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * To maintain support for both plugins and AIP-62 standard wallets,\n   * without introducing dapps breaking changes, we convert\n   * AIP-62 standard compatible wallets to the legacy adapter wallet plugin type.\n   *\n   * @param standardWallet An AIP-62 standard compatible wallet\n   */\n  private standardizeStandardWalletToPluginWalletType = (\n    standardWallet: AptosStandardWallet\n  ) => {\n    let standardWalletConvertedToWallet: Wallet = {\n      name: standardWallet.name as WalletName,\n      url: standardWallet.url,\n      icon: standardWallet.icon,\n      provider: standardWallet,\n      connect: standardWallet.features[\"aptos:connect\"].connect,\n      disconnect: standardWallet.features[\"aptos:disconnect\"].disconnect,\n      network: standardWallet.features[\"aptos:network\"].network,\n      account: standardWallet.features[\"aptos:account\"].account,\n      signAndSubmitTransaction:\n        standardWallet.features[\"aptos:signAndSubmitTransaction\"]\n          ?.signAndSubmitTransaction,\n      signMessage: standardWallet.features[\"aptos:signMessage\"].signMessage,\n      onAccountChange:\n        standardWallet.features[\"aptos:onAccountChange\"].onAccountChange,\n      onNetworkChange:\n        standardWallet.features[\"aptos:onNetworkChange\"].onNetworkChange,\n      signTransaction:\n        standardWallet.features[\"aptos:signTransaction\"].signTransaction,\n      openInMobileApp:\n        standardWallet.features[\"aptos:openInMobileApp\"]?.openInMobileApp,\n      changeNetwork:\n        standardWallet.features[\"aptos:changeNetwork\"]?.changeNetwork,\n      readyState: WalletReadyState.Installed,\n      isAIP62Standard: true,\n    };\n\n    // Remove optional duplications in the _all_wallets array\n    this._all_wallets = this._all_wallets.filter(\n      (item) => item.name !== standardWalletConvertedToWallet.name\n    );\n    this._all_wallets.push(standardWalletConvertedToWallet);\n\n    this.emit(\"standardWalletsAdded\", standardWalletConvertedToWallet);\n  };\n\n  private recordEvent(eventName: string, additionalInfo?: object) {\n    this.ga4.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: process.env.GAID,\n      ...additionalInfo,\n    });\n  }\n\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  private ensureWalletExists(wallet: Wallet | null): asserts wallet is Wallet {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (\n      !(\n        wallet.readyState === WalletReadyState.Loadable ||\n        wallet.readyState === WalletReadyState.Installed\n      )\n    )\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  private ensureAccountExists(\n    account: AccountInfo | null\n  ): asserts account is AccountInfo {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n\n  /**\n   * @deprecated use ensureWalletExists\n   */\n  private doesWalletExist(): boolean | WalletNotConnectedError {\n    if (!this._connected || this._connecting || !this._wallet)\n      throw new WalletNotConnectedError().name;\n    if (\n      !(\n        this._wallet.readyState === WalletReadyState.Loadable ||\n        this._wallet.readyState === WalletReadyState.Installed\n      )\n    )\n      throw new WalletNotReadyError().name;\n    return true;\n  }\n\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  private clearData(): void {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  private async setAnsName(): Promise<void> {\n    if (this._network?.chainId && this._account) {\n      // ANS supports only MAINNET or TESTNET\n      if (\n        !ChainIdToAnsSupportedNetworkMap[this._network.chainId] ||\n        !isAptosNetwork(this._network)\n      ) {\n        this._account.ansName = undefined;\n        return;\n      }\n\n      const aptosConfig = new AptosConfig({\n        network: convertNetwork(this._network),\n      });\n      const aptos = new Aptos(aptosConfig);\n      const name = await aptos.ans.getPrimaryName({\n        address: this._account.address,\n      });\n\n      this._account.ansName = name;\n    }\n  }\n\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet: Wallet | null): void {\n    this._wallet = wallet;\n  }\n\n  /**\n   * Sets the connected account\n   *\n   * `AccountInfo` type comes from a legacy wallet adapter plugin\n   * `StandardAccountInfo` type comes from AIP-62 standard compatible wallet when onAccountChange event is called\n   * `UserResponse<StandardAccountInfo>` type comes from AIP-62 standard compatible wallet on wallet connect\n   *\n   * @param account An account\n   */\n  setAccount(\n    account:\n      | AccountInfo\n      | StandardAccountInfo\n      | UserResponse<StandardAccountInfo>\n      | null\n  ): void {\n    if (account === null) {\n      this._account = null;\n      return;\n    }\n\n    // Check if wallet is of type AIP-62 standard\n    if (this._wallet?.isAIP62Standard) {\n      // Check if account is of type UserResponse<StandardAccountInfo> which means the `account`\n      // comes from the `connect` method\n      if (\"status\" in account) {\n        const connectStandardAccount =\n          account as UserResponse<StandardAccountInfo>;\n        if (connectStandardAccount.status === UserResponseStatus.REJECTED) {\n          this._connecting = false;\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        // account is of type\n        this._account = {\n          address: connectStandardAccount.args.address.toString(),\n          publicKey: connectStandardAccount.args.publicKey.toString(),\n          ansName: connectStandardAccount.args.ansName,\n        };\n        return;\n      } else {\n        // account is of type `StandardAccountInfo` which means it comes from onAccountChange event\n        const standardAccount = account as StandardAccountInfo;\n        this._account = {\n          address: standardAccount.address.toString(),\n          publicKey: standardAccount.publicKey.toString(),\n          ansName: standardAccount.ansName,\n        };\n        return;\n      }\n    }\n\n    // account is of type `AccountInfo`\n    this._account = { ...(account as AccountInfo) };\n    return;\n  }\n\n  /**\n   * Sets the connected network\n   *\n   * `NetworkInfo` type comes from a legacy wallet adapter plugin\n   * `StandardNetworkInfo` type comes from AIP-62 standard compatible wallet\n   *\n   * @param network A network\n   */\n  setNetwork(network: NetworkInfo | StandardNetworkInfo | null): void {\n    if (network === null) {\n      this._network = null;\n      return;\n    }\n    if (this._wallet?.isAIP62Standard) {\n      const standardizeNetwork = network as StandardNetworkInfo;\n      this.recordEvent(\"network_change\", {\n        from: this._network?.name,\n        to: standardizeNetwork.name,\n      });\n      this._network = {\n        name: standardizeNetwork.name.toLowerCase() as Network,\n        chainId: standardizeNetwork.chainId.toString(),\n        url: standardizeNetwork.url,\n      };\n\n      return;\n    }\n\n    this.recordEvent(\"network_change\", {\n      from: this._network?.name,\n      to: network.name,\n    });\n    this._network = {\n      ...(network as NetworkInfo),\n      name: network.name.toLowerCase() as Network,\n    };\n  }\n\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected(): boolean {\n    return this._connected;\n  }\n\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets(): ReadonlyArray<Wallet | AptosStandardSupportedWallet> {\n    return this._all_wallets;\n  }\n\n  /**\n   * Getter to fetch all detected plugin wallets\n   */\n  get pluginWallets(): ReadonlyArray<Wallet> {\n    return this._wallets;\n  }\n\n  /**\n   * Getter to fetch all detected AIP-62 standard compatible wallets\n   */\n  get standardWallets(): ReadonlyArray<AptosStandardWallet> {\n    return this._standard_wallets;\n  }\n\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet(): WalletInfo | null {\n    try {\n      if (!this._wallet) return null;\n      return {\n        name: this._wallet.name,\n        icon: this._wallet.icon,\n        url: this._wallet.url,\n      };\n    } catch (error: any) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account(): AccountInfo | null {\n    try {\n      return this._account;\n    } catch (error: any) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network(): NetworkInfo | null {\n    try {\n      return this._network;\n    } catch (error: any) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName: string): Promise<void | string> {\n    // Checks the wallet exists in the detected wallets array\n\n    const allDetectedWallets = this._all_wallets as Array<Wallet>;\n\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: Wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) return;\n\n    // Check if wallet is already connected\n    if (this._connected) {\n      // if the selected wallet is already connected, we don't need to connect again\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n\n    // Check if we are in a redirectable view (i.e on mobile AND not in an in-app browser)\n    // Ignore if wallet is installed (iOS extension)\n    if (\n      isRedirectable() &&\n      selectedWallet.readyState !== WalletReadyState.Installed\n    ) {\n      // use wallet deep link\n      if (selectedWallet.isAIP62Standard && selectedWallet.openInMobileApp) {\n        selectedWallet.openInMobileApp();\n        return;\n      }\n      if (selectedWallet.deeplinkProvider) {\n        const url = encodeURIComponent(window.location.href);\n        const location = selectedWallet.deeplinkProvider({ url });\n        window.location.href = location;\n      }\n      return;\n    }\n\n    // Check wallet state is Installed or Loadable\n    if (\n      selectedWallet.readyState !== WalletReadyState.Installed &&\n      selectedWallet.readyState !== WalletReadyState.Loadable\n    ) {\n      return;\n    }\n\n    // Now we can connect to the wallet\n    await this.connectWallet(selectedWallet);\n  }\n\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  async connectWallet(selectedWallet: Wallet): Promise<void> {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      let account;\n      if (selectedWallet.isAIP62Standard) {\n        account = await this.walletStandardCore.connect(selectedWallet);\n      } else {\n        account = await this.walletCoreV1.connect(selectedWallet);\n      }\n      this.setAccount(account);\n      const network = await selectedWallet.network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n    } catch (error: any) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @param options optional. A configuration object to generate a transaction by\n   * @returns The pending transaction hash (V1 output) | PendingTransactionResponse (V2 output)\n   */\n  async signAndSubmitTransaction(\n    transactionInput: InputTransactionData\n  ): Promise<\n    { hash: Types.HexEncodedBytes; output?: any } | PendingTransactionResponse\n  > {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (\n          transactionInput.data.function ===\n          \"0x1::account::rotate_authentication_key_call\"\n        ) {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\")\n            .message;\n        }\n      }\n\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n      // get the payload piece from the input\n      const payloadData = transactionInput.data;\n      const aptosConfig = getAptosConfig(this._network);\n\n      const aptos = new Aptos(aptosConfig);\n\n      if (this._wallet.signAndSubmitTransaction) {\n        // if wallet is compatible with the AIP-62 standard\n        if (this._wallet.isAIP62Standard) {\n          const { hash, ...output } =\n            await this.walletStandardCore.signAndSubmitTransaction(\n              transactionInput,\n              aptos,\n              this._account,\n              this._wallet\n            );\n          return { hash, output };\n        } else {\n          // Else use wallet plugin\n          const { hash, ...output } =\n            await this.walletCoreV1.resolveSignAndSubmitTransaction(\n              payloadData,\n              this._network,\n              this._wallet,\n              transactionInput\n            );\n          return { hash, output };\n        }\n      }\n\n      // If wallet does not support signAndSubmitTransaction\n      // the adapter will sign and submit it for the dapp.\n      // Note: This should happen only for AIP-62 standard compatible wallets since\n      // signAndSubmitTransaction is not a required function implementation\n      const transaction = await aptos.transaction.build.simple({\n        sender: this._account.address,\n        data: transactionInput.data,\n        options: transactionInput.options,\n      });\n\n      const senderAuthenticator = await this.signTransaction(transaction);\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator,\n      });\n      return response;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a transaction\n   *\n   * To support both existing wallet adapter V1 and V2, we support 2 input types\n   *\n   * @param transactionOrPayload AnyRawTransaction - V2 input | Types.TransactionPayload - V1 input\n   * @param options optional. V1 input\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(\n    transactionOrPayload: AnyRawTransaction | Types.TransactionPayload,\n    asFeePayer?: boolean,\n    options?: InputGenerateTransactionOptions\n  ): Promise<AccountAuthenticator> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_transaction\");\n      // Make sure wallet supports signTransaction\n      if (this._wallet.signTransaction) {\n        // If current connected wallet is AIP-62 standard compatible\n        // we want to make sure the transaction input is what the\n        // standard expects, i,e new sdk v2 input\n        if (this._wallet.isAIP62Standard) {\n          // if rawTransaction prop it means transaction input data is\n          // compatible with new sdk v2 input\n          if (\"rawTransaction\" in transactionOrPayload) {\n            return await this.walletStandardCore.signTransaction(\n              transactionOrPayload,\n              this._wallet,\n              asFeePayer\n            );\n          } else {\n            const aptosConfig = getAptosConfig(this._network);\n            this.ensureAccountExists(this._account);\n            const sender = this._account.address;\n            const payload = await generateTransactionPayloadFromV1Input(\n              aptosConfig,\n              transactionOrPayload\n            );\n            const optionsV1 = options as CompatibleTransactionOptions;\n            const optionsV2 = {\n              accountSequenceNumber: optionsV1?.sequenceNumber,\n              expireTimestamp:\n                optionsV1?.expireTimestamp ?? optionsV1?.expirationTimestamp,\n              gasUnitPrice:\n                optionsV1?.gasUnitPrice ?? optionsV1?.gas_unit_price,\n              maxGasAmount:\n                optionsV1?.maxGasAmount ?? optionsV1?.max_gas_amount,\n            };\n            const rawTransaction = await generateRawTransaction({\n              aptosConfig,\n              payload,\n              sender,\n              options: optionsV2,\n            });\n            return await this.walletStandardCore.signTransaction(\n              new SimpleTransaction(rawTransaction),\n              this._wallet,\n              false\n            );\n          }\n        }\n\n        // If current connected wallet is legacy compatible with wallet standard\n\n        // if input is AnyRawTransaction, i.e new sdk v2 input\n        if (\"rawTransaction\" in transactionOrPayload) {\n          const accountAuthenticator = (await this._wallet.signTransaction(\n            transactionOrPayload,\n            asFeePayer\n          )) as AccountAuthenticator;\n\n          return accountAuthenticator;\n        } else {\n          const response = await this.walletCoreV1.signTransaction(\n            transactionOrPayload as Types.TransactionPayload,\n            this._wallet!,\n            {\n              max_gas_amount: options?.maxGasAmount\n                ? BigInt(options?.maxGasAmount)\n                : undefined,\n              gas_unit_price: options?.gasUnitPrice\n                ? BigInt(options?.gasUnitPrice)\n                : undefined,\n            }\n          );\n\n          if (!response) {\n            throw new Error(\"error\");\n          }\n\n          // Convert retuned bcs serialized SignedTransaction into V2 AccountAuthenticator\n          const deserializer1 = new BCS.Deserializer(response);\n          const deserializedSignature =\n            TxnBuilderTypes.SignedTransaction.deserialize(deserializer1);\n          const transactionAuthenticator =\n            deserializedSignature.authenticator as TxnBuilderTypes.TransactionAuthenticatorEd25519;\n\n          const publicKey = transactionAuthenticator.public_key.value;\n          const signature = transactionAuthenticator.signature.value;\n\n          const accountAuthenticator = new AccountAuthenticatorEd25519(\n            new Ed25519PublicKey(publicKey),\n            new Ed25519Signature(signature)\n          );\n          return accountAuthenticator;\n        }\n      }\n\n      // If we are here it means this wallet does not support signTransaction\n      throw new WalletNotSupportedMethod(\n        `Sign Transaction is not supported by ${this.wallet?.name}`\n      ).message;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sign message (doesnt submit to chain).\n   *\n   * @param message\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(message: SignMessagePayload): Promise<SignMessageResponse> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n      if (this._wallet.isAIP62Standard) {\n        return await this.walletStandardCore.signMessage(message, this._wallet);\n      }\n      const response = await this._wallet!.signMessage(message);\n      return response as SignMessageResponse;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> {\n    try {\n      this.ensureWalletExists(this._wallet);\n\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType =\n        additionalSignersAuthenticators !== undefined\n          ? \"multi-agent\"\n          : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType,\n      });\n      // If wallet supports submitTransaction transaction function\n      if (this._wallet.submitTransaction) {\n        const pendingTransaction =\n          await this._wallet.submitTransaction(transaction);\n        return pendingTransaction;\n      }\n\n      // Else have the adapter submit the transaction\n\n      const aptosConfig = new AptosConfig({\n        network: convertNetwork(this.network),\n      });\n      const aptos = new Aptos(aptosConfig);\n      if (additionalSignersAuthenticators !== undefined) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators,\n        };\n        return aptos.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return aptos.transaction.submit.simple(transaction);\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n  Event for when account has changed on the wallet\n  @return the new account info\n  @throws WalletAccountChangeError\n  */\n  async onAccountChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.onAccountChange(\n        async (data: AccountInfo | StandardAccountInfo) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n\n  /**\n  Event for when network has changed on the wallet\n  @return the new network info\n  @throws WalletNetworkChangeError\n  */\n  async onNetworkChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.onNetworkChange(\n        async (data: NetworkInfo | StandardNetworkInfo) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network\n   * @returns AptosChangeNetworkOutput\n   */\n  async changeNetwork(network: Network): Promise<AptosChangeNetworkOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network,\n      });\n      const chainId =\n        network === Network.DEVNET\n          ? await fetchDevnetChainId()\n          : NetworkToChainId[network];\n      if (this._wallet.changeNetwork) {\n        const networkInfo: StandardNetworkInfo = {\n          name: network,\n          chainId,\n        };\n        const response = await this._wallet.changeNetwork(networkInfo);\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message SignMessagePayload\n   * @returns boolean\n   */\n  async signMessageAndVerify(message: SignMessagePayload): Promise<boolean> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n      // If current connected wallet is AIP-62 standard compatible\n      if (this._wallet.isAIP62Standard) {\n        return this.walletStandardCore.signMessageAndVerify(\n          message,\n          this._wallet\n        );\n      }\n\n      return await this.walletCoreV1.signMessageAndVerify(\n        message,\n        this._wallet,\n        this._account\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","import { TWallet } from \"@atomrigslab/aptos-wallet-adapter\";\nimport { AptosStandardWallet } from \"./WalletStandard\";\n\nconst sdkWallets: AptosStandardWallet[] = [];\n\nsdkWallets.push(new TWallet());\n\nexport default sdkWallets;\n","export enum WalletReadyState {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  Installed = \"Installed\",\n  NotDetected = \"NotDetected\",\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n  Loadable = \"Loadable\",\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n  Unsupported = \"Unsupported\",\n}\n\nexport enum NetworkName {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n  Devnet = \"devnet\",\n}\n\nexport const ChainIdToAnsSupportedNetworkMap: Record<string, string> = {\n  \"1\": \"mainnet\", // mainnet\n  \"2\": \"testnet\", // testnet\n};\n","export class WalletError extends Error {\n  public error: any;\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(message?: string, error?: any) {\n    super(message);\n    this.error = error;\n  }\n}\n\nexport class WalletNotSelectedError extends WalletError {\n  name = \"WalletNotSelectedError\";\n}\n\nexport class WalletNotReadyError extends WalletError {\n  name = \"WalletNotReadyError\";\n}\n\nexport class WalletLoadError extends WalletError {\n  name = \"WalletLoadError\";\n}\n\nexport class WalletConfigError extends WalletError {\n  name = \"WalletConfigError\";\n}\n\nexport class WalletConnectionError extends WalletError {\n  name = \"WalletConnectionError\";\n}\n\nexport class WalletDisconnectedError extends WalletError {\n  name = \"WalletDisconnectedError\";\n}\n\nexport class WalletDisconnectionError extends WalletError {\n  name = \"WalletDisconnectionError\";\n}\n\nexport class WalletAccountError extends WalletError {\n  name = \"WalletAccountError\";\n}\nexport class WalletGetNetworkError extends WalletError {\n  name = \"WalletGetNetworkError\";\n}\n\nexport class WalletAccountChangeError extends WalletError {\n  name = \"WalletAccountChangeError\";\n}\n\nexport class WalletNetworkChangeError extends WalletError {\n  name = \"WalletNetworkChangeError\";\n}\n\nexport class WalletPublicKeyError extends WalletError {\n  name = \"WalletPublicKeyError\";\n}\n\nexport class WalletKeypairError extends WalletError {\n  name = \"WalletKeypairError\";\n}\n\nexport class WalletNotConnectedError extends WalletError {\n  name = \"WalletNotConnectedError\";\n}\n\nexport class WalletSendTransactionError extends WalletError {\n  name = \"WalletSendTransactionError\";\n}\n\nexport class WalletSignMessageError extends WalletError {\n  name = \"WalletSignMessageError\";\n}\n\nexport class WalletSignMessageAndVerifyError extends WalletError {\n  name = \"WalletSignMessageAndVerifyError\";\n}\n\nexport class WalletSignAndSubmitMessageError extends WalletError {\n  name = \"WalletSignAndSubmitMessageError\";\n}\n\nexport class WalletSignTransactionError extends WalletError {\n  name = \"WalletSignTransactionError\";\n}\n\nexport class WalletTimeoutError extends WalletError {\n  name = \"WalletTimeoutError\";\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n  name = \"WalletWindowBlockedError\";\n}\n\nexport class WalletWindowClosedError extends WalletError {\n  name = \"WalletWindowClosedError\";\n}\n\nexport class WalletResponseError extends WalletError {\n  name = \"WalletResponseError\";\n}\n\nexport class WalletNotSupportedMethod extends WalletError {\n  name = \"WalletNotSupportedMethod\";\n}\n\nexport class WalletChangeNetworkError extends WalletError {\n  name = \"WalletChangeNetworkError\";\n}\n","import { HexString, TxnBuilderTypes, Types } from \"aptos\";\nimport EventEmitter from \"eventemitter3\";\nimport { Buffer } from \"buffer\";\nimport {\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadData,\n  generateTransactionPayload,\n} from \"@aptos-labs/ts-sdk\";\nimport nacl from \"tweetnacl\";\nimport {\n  WalletNotSupportedMethod,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageAndVerifyError,\n  WalletSignTransactionError,\n} from \"../error\";\nimport {\n  Wallet,\n  WalletCoreEvents,\n  TransactionOptions,\n  NetworkInfo,\n  InputTransactionData,\n  AccountInfo,\n  SignMessagePayload,\n  SignMessageResponse,\n} from \"./types\";\n\nimport {\n  convertV2PayloadToV1JSONPayload,\n  convertV2TransactionPayloadToV1BCSPayload,\n} from \"./conversion\";\nimport {\n  areBCSArguments,\n  generalizedErrorMessage,\n  getAptosConfig,\n} from \"../utils\";\n\nexport class WalletCoreV1 extends EventEmitter<WalletCoreEvents> {\n  async connect(wallet: Wallet) {\n    const account = await wallet.connect();\n    return account;\n  }\n\n  /**\n   * Resolve the transaction type (BCS arguments or Simple arguments)\n   *\n   * @param payloadData\n   * @param network\n   * @param wallet\n   * @param transactionInput\n   *\n   * @returns\n   */\n  async resolveSignAndSubmitTransaction(\n    payloadData: InputGenerateTransactionPayloadData,\n    network: NetworkInfo | null,\n    wallet: Wallet,\n    transactionInput: InputTransactionData\n  ) {\n    // first check if each argument is a BCS serialized argument\n    if (areBCSArguments(payloadData.functionArguments)) {\n      const aptosConfig = getAptosConfig(network);\n      const newPayload = await generateTransactionPayload({\n        ...(payloadData as InputEntryFunctionDataWithRemoteABI),\n        aptosConfig: aptosConfig,\n      });\n      const oldTransactionPayload =\n        convertV2TransactionPayloadToV1BCSPayload(newPayload);\n      // Call and return signAndSubmitBCSTransaction response\n      return await this.signAndSubmitBCSTransaction(\n        oldTransactionPayload,\n        wallet!,\n        {\n          max_gas_amount: transactionInput.options?.maxGasAmount\n            ? BigInt(transactionInput.options?.maxGasAmount)\n            : undefined,\n          gas_unit_price: transactionInput.options?.gasUnitPrice\n            ? BigInt(transactionInput.options?.gasUnitPrice)\n            : undefined,\n        }\n      );\n    }\n\n    // if it is not a bcs serialized arguments transaction, convert to the old\n    // json format\n    const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);\n    return await this.signAndSubmitTransaction(oldTransactionPayload, wallet!, {\n      max_gas_amount: transactionInput.options?.maxGasAmount\n        ? BigInt(transactionInput.options?.maxGasAmount)\n        : undefined,\n      gas_unit_price: transactionInput.options?.gasUnitPrice\n        ? BigInt(transactionInput.options?.gasUnitPrice)\n        : undefined,\n    });\n  }\n\n  /**\n  Sign and submit an entry (not bcs serialized) transaction type to chain.\n  @param transaction a non-bcs serialized transaction\n  @param options max_gas_amount and gas_unit_limit\n  @return response from the wallet's signAndSubmitTransaction function\n  @throws WalletSignAndSubmitMessageError\n  */\n  async signAndSubmitTransaction(\n    transaction: Types.TransactionPayload,\n    wallet: Wallet,\n    options?: TransactionOptions\n  ): Promise<any> {\n    try {\n      const response = await (wallet as any).signAndSubmitTransaction(\n        transaction,\n        options\n      );\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   Sign and submit a bsc serialized transaction type to chain.\n   @param transaction a bcs serialized transaction\n   @param options max_gas_amount and gas_unit_limit\n   @return response from the wallet's signAndSubmitBCSTransaction function\n   @throws WalletSignAndSubmitMessageError\n   */\n  async signAndSubmitBCSTransaction(\n    transaction: TxnBuilderTypes.TransactionPayload,\n    wallet: Wallet,\n    options?: TransactionOptions\n  ): Promise<any> {\n    if (!(\"signAndSubmitBCSTransaction\" in wallet)) {\n      throw new WalletNotSupportedMethod(\n        `Submit a BCS Transaction is not supported by ${wallet.name}`\n      ).message;\n    }\n    try {\n      const response = await (wallet as any).signAndSubmitBCSTransaction(\n        transaction,\n        options\n      );\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   Sign transaction\n   @param transaction\n   @param options max_gas_amount and gas_unit_limit\n   @return response from the wallet's signTransaction function\n   @throws WalletSignTransactionError\n   */\n  async signTransaction(\n    transaction: Types.TransactionPayload,\n    wallet: Wallet,\n    options?: TransactionOptions\n  ): Promise<Uint8Array | null> {\n    try {\n      const response = await (wallet as any).signTransaction(\n        transaction,\n        options\n      );\n      return response;\n    } catch (error: any) {\n      const errMsg =\n        typeof error == \"object\" && \"message\" in error ? error.message : error;\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message SignMessagePayload\n   * @returns boolean\n   */\n  async signMessageAndVerify(\n    message: SignMessagePayload,\n    wallet: Wallet,\n    account: AccountInfo\n  ): Promise<boolean> {\n    try {\n      const response = await wallet.signMessage(message);\n      if (!response)\n        throw new WalletSignMessageAndVerifyError(\"Failed to sign a message\")\n          .message;\n      console.log(\"signMessageAndVerify signMessage response\", response);\n\n      // Verify that the bytes were signed using the private key that matches the known public key\n      let verified = false;\n      if (Array.isArray((response as SignMessageResponse).signature)) {\n        // multi sig wallets\n        const { fullMessage, signature, bitmap } =\n          response as SignMessageResponse;\n        if (bitmap) {\n          const minKeysRequired = account.minKeysRequired as number;\n          if ((signature as string[]).length < minKeysRequired) {\n            verified = false;\n          } else {\n            // Getting an array which marks the keys signing the message with 1, while marking 0 for the keys not being used.\n            const bits = Array.from(bitmap).flatMap((n) =>\n              Array.from({ length: 8 }).map((_, i) => (n >> i) & 1)\n            );\n            // Filter out indexes of the keys we need\n            const index = bits.map((_, i) => i).filter((i) => bits[i]);\n\n            const publicKeys = account.publicKey as string[];\n            const matchedPublicKeys = publicKeys.filter(\n              (_: string, i: number) => index.includes(i)\n            );\n\n            verified = true;\n            for (let i = 0; i < (signature as string[]).length; i++) {\n              const isSigVerified = nacl.sign.detached.verify(\n                Buffer.from(fullMessage),\n                Buffer.from((signature as string[])[i], \"hex\"),\n                Buffer.from(matchedPublicKeys[i], \"hex\")\n              ); // `isSigVerified` should be `true` for every signature\n\n              if (!isSigVerified) {\n                verified = false;\n                break;\n              }\n            }\n          }\n        } else {\n          throw new WalletSignMessageAndVerifyError(\"Failed to get a bitmap\")\n            .message;\n        }\n      } else {\n        // single sig wallets\n        // support for when address doesnt have hex prefix (0x)\n        const currentAccountPublicKey = new HexString(\n          account.publicKey as string\n        );\n        // support for when address doesnt have hex prefix (0x)\n        const signature = new HexString(\n          (response as SignMessageResponse).signature as string\n        );\n        verified = nacl.sign.detached.verify(\n          Buffer.from((response as SignMessageResponse).fullMessage),\n          Buffer.from(signature.noPrefix(), \"hex\"),\n          Buffer.from(currentAccountPublicKey.noPrefix(), \"hex\")\n        );\n      }\n      return verified;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","import {\n  Network,\n  TransactionPayload,\n  InputGenerateTransactionPayloadData,\n  TypeTag,\n  AptosConfig,\n  InputEntryFunctionData,\n  InputMultiSigData,\n  MoveFunctionId,\n  generateTransactionPayload,\n  TransactionPayloadEntryFunction,\n} from \"@aptos-labs/ts-sdk\";\nimport { NetworkInfo as StandardNetworkInfo } from \"@aptos-labs/wallet-standard\";\nimport { BCS, TxnBuilderTypes, Types } from \"aptos\";\nimport { NetworkInfo } from \"./types\";\n\n// old => new\nexport function convertNetwork(\n  networkInfo: NetworkInfo | StandardNetworkInfo | null\n): Network {\n  switch (networkInfo?.name) {\n    case \"mainnet\" as Network:\n      return Network.MAINNET;\n    case \"testnet\" as Network:\n      return Network.TESTNET;\n    case \"devnet\" as Network:\n      return Network.DEVNET;\n    default:\n      throw new Error(\"Invalid Aptos network name\");\n  }\n}\n\n// new => old\nexport function convertV2TransactionPayloadToV1BCSPayload(\n  payload: TransactionPayload\n): TxnBuilderTypes.TransactionPayload {\n  const deserializer = new BCS.Deserializer(payload.bcsToBytes());\n  return TxnBuilderTypes.TransactionPayload.deserialize(deserializer);\n}\n\nexport function convertV2PayloadToV1JSONPayload(\n  payload: InputGenerateTransactionPayloadData\n): Types.TransactionPayload {\n  if (\"bytecode\" in payload) {\n    // is a script payload\n    throw new Error(\"script payload not supported\");\n    // is multisig function payload\n  } else if (\"multisigAddress\" in payload) {\n    const stringTypeTags: string[] | undefined = payload.typeArguments?.map(\n      (typeTag) => {\n        if (typeTag instanceof TypeTag) {\n          return typeTag.toString();\n        }\n        return typeTag;\n      }\n    );\n    const newPayload: Types.TransactionPayload = {\n      type: \"multisig_payload\",\n      multisig_address: payload.multisigAddress.toString(),\n      function: payload.function,\n      type_arguments: stringTypeTags || [],\n      arguments: payload.functionArguments,\n    };\n\n    return newPayload;\n  } else {\n    // is entry function payload\n    const stringTypeTags: string[] | undefined = payload.typeArguments?.map(\n      (typeTag) => {\n        if (typeTag instanceof TypeTag) {\n          return typeTag.toString();\n        }\n        return typeTag;\n      }\n    );\n    const newPayload: Types.TransactionPayload = {\n      type: \"entry_function_payload\",\n      function: payload.function,\n      type_arguments: stringTypeTags || [],\n      arguments: payload.functionArguments,\n    };\n\n    return newPayload;\n  }\n}\n\nexport async function generateTransactionPayloadFromV1Input(\n  aptosConfig: AptosConfig,\n  inputV1: Types.TransactionPayload\n): Promise<TransactionPayloadEntryFunction> {\n  if (\"function\" in inputV1) {\n    const inputV2: InputEntryFunctionData | InputMultiSigData = {\n      function: inputV1.function as MoveFunctionId,\n      functionArguments: inputV1.arguments,\n      typeArguments: inputV1.type_arguments,\n    };\n    return generateTransactionPayload({ ...inputV2, aptosConfig });\n  }\n\n  throw new Error(\"Payload type not supported\");\n}\n\nexport interface CompatibleTransactionOptions {\n  expireTimestamp?: number;\n  expirationSecondsFromNow?: number;\n  expirationTimestamp?: number;\n  gasUnitPrice?: number;\n  gas_unit_price?: number;\n  maxGasAmount?: number;\n  max_gas_amount?: number;\n  sender?: string;\n  sequenceNumber?: number;\n}\n","export function scopePollingDetectionStrategy(detect: () => boolean): void {\n  // Early return when server-side rendering\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n\n  const disposers: (() => void)[] = [];\n\n  function detectAndDispose() {\n    const detected = detect();\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  }\n\n  // Strategy #1: Try detecting every second.\n  const interval =\n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval));\n\n  // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n  if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === \"loading\"\n  ) {\n    document.addEventListener(\"DOMContentLoaded\", detectAndDispose, {\n      once: true,\n    });\n    disposers.push(() =>\n      document.removeEventListener(\"DOMContentLoaded\", detectAndDispose)\n    );\n  }\n\n  // Strategy #3: Detect after the `window` has fully loaded.\n  if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== \"complete\"\n  ) {\n    window.addEventListener(\"load\", detectAndDispose, { once: true });\n    disposers.push(() => window.removeEventListener(\"load\", detectAndDispose));\n  }\n\n  // Strategy #4: Detect synchronously, now.\n  detectAndDispose();\n}\n","import { WalletName } from \"../LegacyWalletPlugins/types\";\n\nconst LOCAL_STORAGE_ITEM_KEY = \"AptosWalletName\";\n\nexport function setLocalStorage(walletName: WalletName) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\n\nexport function removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\nexport function getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n","import {\n  Aptos,\n  AptosConfig,\n  EntryFunctionArgumentTypes,\n  Network,\n  NetworkToNodeAPI,\n  Serializable,\n  SimpleEntryFunctionArgumentTypes,\n} from \"@aptos-labs/ts-sdk\";\nimport { NetworkInfo as StandardNetworkInfo } from \"@aptos-labs/wallet-standard\";\nimport { NetworkInfo } from \"../LegacyWalletPlugins/types\";\nimport { convertNetwork } from \"../LegacyWalletPlugins/conversion\";\n\nexport function isMobile(): boolean {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent\n  );\n}\n\nexport function isInAppBrowser(): boolean {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent\n  );\n\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent\n  );\n\n  return isIphone || isAndroid;\n}\n\nexport function isRedirectable(): boolean {\n  // SSR: return false\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n\n  // if we are on mobile and NOT in a in-app browser we will redirect to a wallet app\n\n  return isMobile() && !isInAppBrowser();\n}\n\nexport function generalizedErrorMessage(error: any): string {\n  return typeof error === \"object\" && \"message\" in error\n    ? error.message\n    : error;\n}\n\n// Helper function to check if input arguments are BCS serialized arguments.\n// In @aptos-labs/ts-sdk each move representative class extends\n// Serializable, so if each argument is of an instance of a class\n// the extends Serializable - we know these are BCS arguments\nexport const areBCSArguments = (\n  args: Array<EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes>\n): boolean => {\n  // `every` returns true if the array is empty, so\n  // first check the array length\n  if (args.length === 0) return false;\n  return args.every(\n    (arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes) =>\n      arg instanceof Serializable\n  );\n};\n\n/**\n * Helper function to get AptosConfig that supports Aptos and Custom networks\n *\n * @param networkInfo\n * @returns AptosConfig\n */\nexport const getAptosConfig = (\n  networkInfo: NetworkInfo | StandardNetworkInfo | null\n): AptosConfig => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  if (isAptosNetwork(networkInfo)) {\n    return new AptosConfig({\n      network: convertNetwork(networkInfo),\n    });\n  }\n  return new AptosConfig({\n    network: Network.CUSTOM,\n    fullnode: networkInfo.url,\n  });\n};\n\n/**\n * Helper function to resolve if the current connected network is an Aptos network\n *\n * @param networkInfo\n * @returns boolean\n */\nexport const isAptosNetwork = (\n  networkInfo: NetworkInfo | StandardNetworkInfo | null\n): boolean => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== undefined;\n};\n\n/**\n * Helper function to fetch Devnet chain id\n */\nexport const fetchDevnetChainId = async (): Promise<number> => {\n  const aptos = new Aptos(); // default to devnet\n  return await aptos.getChainId();\n};\n","import { Types } from \"aptos\";\nimport {\n  Network,\n  InputGenerateTransactionOptions,\n  InputSubmitTransactionData,\n  PendingTransactionResponse,\n  AccountAddressInput,\n  InputGenerateTransactionPayloadData,\n  AnyRawTransaction,\n  Signature,\n} from \"@aptos-labs/ts-sdk\";\nimport { WalletReadyState } from \"../constants\";\nimport {\n  AptosSignAndSubmitTransactionOutput,\n  AptosSignMessageOutput,\n  UserResponse,\n  AccountInfo as StandardAccountInfo,\n  NetworkInfo as StandardNetworkInfo,\n  AptosChangeNetworkMethod,\n} from \"@aptos-labs/wallet-standard\";\nimport { AptosStandardSupportedWallet } from \"../AIP62StandardWallets/types\";\n\nexport { TxnBuilderTypes, Types } from \"aptos\";\nexport type {\n  InputGenerateTransactionData,\n  InputGenerateTransactionOptions,\n  AnyRawTransaction,\n  InputSubmitTransactionData,\n  PendingTransactionResponse,\n  AccountAuthenticator,\n  Network,\n} from \"@aptos-labs/ts-sdk\";\n\nexport type {\n  NetworkInfo as StandardNetworkInfo,\n  AptosChangeNetworkOutput,\n} from \"@aptos-labs/wallet-standard\";\n\n// WalletName is a nominal type that wallet adapters should use, e.g. `'MyCryptoWallet' as WalletName<'MyCryptoWallet'>`\nexport type WalletName<T extends string = string> = T & {\n  __brand__: \"WalletName\";\n};\n\nexport type NetworkInfo = {\n  name: Network;\n  chainId?: string;\n  url?: string;\n};\n\nexport type WalletInfo = {\n  name: WalletName;\n  icon: string;\n  url: string;\n};\n\nexport type AccountInfo = {\n  address: string;\n  publicKey: string | string[];\n  minKeysRequired?: number;\n  ansName?: string | null;\n};\n\nexport interface AptosWalletErrorResult {\n  code: number;\n  name: string;\n  message: string;\n}\n\nexport declare interface WalletCoreEvents {\n  connect(account: AccountInfo | null): void;\n  disconnect(): void;\n  readyStateChange(wallet: Wallet): void;\n  standardWalletsAdded(wallets: Wallet | AptosStandardSupportedWallet): void;\n  networkChange(network: NetworkInfo | null): void;\n  accountChange(account: AccountInfo | null): void;\n}\n\nexport interface SignMessagePayload {\n  address?: boolean; // Should we include the address of the account in the message\n  application?: boolean; // Should we include the domain of the dapp\n  chainId?: boolean; // Should we include the current chain id the wallet is connected to\n  message: string; // The message to be signed and displayed to the user\n  nonce: string; // A nonce the dapp should generate\n}\n\nexport interface SignMessageResponse {\n  address?: string;\n  application?: string;\n  chainId?: number;\n  fullMessage: string; // The message that was generated to sign\n  message: string; // The message passed in by the user\n  nonce: string;\n  prefix: \"APTOS\"; // Should always be APTOS\n  signature: string | string[] | Signature; // The signed full message\n  bitmap?: Uint8Array; // a 4-byte (32 bits) bit-vector of length N\n}\n\nexport type OnNetworkChange = (\n  callBack: (networkInfo: NetworkInfo | StandardNetworkInfo) => Promise<void>\n) => Promise<void>;\n\nexport type OnAccountChange = (\n  callBack: (accountInfo: AccountInfo | StandardAccountInfo) => Promise<any>\n) => Promise<void>;\n\nexport interface AdapterPluginEvents {\n  onNetworkChange: OnNetworkChange;\n  onAccountChange: OnAccountChange;\n}\n\n// TODO add signTransaction()\nexport interface AdapterPluginProps<Name extends string = string> {\n  name: WalletName<Name>;\n  url: string;\n  icon: `data:image/${\"svg+xml\" | \"webp\" | \"png\" | \"gif\"};base64,${string}`;\n  providerName?: string;\n  provider: any;\n  // Compatible with legacy wallet plugin\n  deeplinkProvider?: (data: { url: string }) => string;\n  // Comaptible with AIP-62 standard wallet\n  openInMobileApp?: () => void;\n  connect(): Promise<any>;\n  disconnect: () => Promise<any>;\n  network: () => Promise<any>;\n  signAndSubmitTransaction?(\n    transaction:\n      | Types.TransactionPayload\n      | InputTransactionData\n      | AnyRawTransaction,\n    options?: InputGenerateTransactionOptions\n  ): Promise<\n    | { hash: Types.HexEncodedBytes; output?: any }\n    | PendingTransactionResponse\n    | UserResponse<AptosSignAndSubmitTransactionOutput>\n  >;\n  submitTransaction?(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse>;\n  signMessage<T extends SignMessagePayload>(\n    message: T\n  ): Promise<SignMessageResponse | UserResponse<AptosSignMessageOutput>>;\n  signTransaction?( // `any` type for backwards compatibility, especially for identity connect\n    transactionOrPayload: any,\n    optionsOrAsFeePayer?: any\n  ): Promise<any>;\n  account?: () => Promise<AccountInfo | StandardAccountInfo>;\n  changeNetwork?: AptosChangeNetworkMethod;\n}\n\nexport type AdapterPlugin<Name extends string = string> =\n  AdapterPluginProps<Name> & AdapterPluginEvents;\n\nexport type Wallet<Name extends string = string> = AdapterPlugin<Name> & {\n  readyState?: WalletReadyState;\n  isAIP62Standard?: boolean;\n};\n\nexport interface TransactionOptions {\n  max_gas_amount?: bigint;\n  gas_unit_price?: bigint;\n}\n\nexport type InputTransactionData = {\n  sender?: AccountAddressInput;\n  data: InputGenerateTransactionPayloadData;\n  options?: InputGenerateTransactionOptions;\n};\n\n// To be used by a wallet plugin\nexport interface PluginProvider {\n  connect: () => Promise<AccountInfo>;\n  account: () => Promise<AccountInfo>;\n  disconnect: () => Promise<void>;\n  signAndSubmitTransaction: (\n    transaction: any,\n    options?: any\n  ) => Promise<{ hash: Types.HexEncodedBytes } | AptosWalletErrorResult>;\n  signMessage: (message: SignMessagePayload) => Promise<SignMessageResponse>;\n  network: () => Promise<NetworkInfo>;\n  onAccountChange: (\n    listener: (newAddress: AccountInfo) => Promise<void>\n  ) => Promise<void>;\n  onNetworkChange: OnNetworkChange;\n}\n","import {\n  UserResponse,\n  AptosSignTransactionOutput,\n  AptosSignMessageOutput,\n  AptosSignMessageInput,\n  AptosWallet,\n  UserResponseStatus,\n  AptosSignAndSubmitTransactionOutput,\n  AccountInfo as StandardAccountInfo,\n  AptosConnectOutput,\n} from \"@aptos-labs/wallet-standard\";\nimport {\n  AnyRawTransaction,\n  PendingTransactionResponse,\n  Aptos,\n  MultiEd25519Signature,\n  MultiEd25519PublicKey,\n} from \"@aptos-labs/ts-sdk\";\n\nimport { WalletReadyState } from \"../constants\";\nimport {\n  WalletConnectionError,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageAndVerifyError,\n  WalletSignMessageError,\n} from \"../error\";\nimport {\n  AccountInfo,\n  InputTransactionData,\n  Wallet,\n} from \"../LegacyWalletPlugins\";\nimport { generalizedErrorMessage } from \"../utils\";\n\nexport type AptosStandardWallet = AptosWallet & {\n  readyState?: WalletReadyState;\n};\n\nexport class WalletStandardCore {\n  async connect(wallet: Wallet) {\n    const response =\n      (await wallet.connect()) as UserResponse<AptosConnectOutput>;\n\n    if (response.status === UserResponseStatus.REJECTED) {\n      throw new WalletConnectionError(\"User has rejected the request\").message;\n    }\n    return response.args;\n  }\n\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async signAndSubmitTransaction(\n    transactionInput: InputTransactionData,\n    aptos: Aptos,\n    account: AccountInfo,\n    wallet: Wallet\n  ): Promise<PendingTransactionResponse> {\n    try {\n      const transaction = await aptos.transaction.build.simple({\n        sender: account.address.toString(),\n        data: transactionInput.data,\n        options: transactionInput.options,\n      });\n      const response = (await wallet.signAndSubmitTransaction!(\n        transaction\n      )) as UserResponse<AptosSignAndSubmitTransactionOutput>;\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return response.args;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a transaction\n   *\n   * To support both existing wallet adapter V1 and V2, we support 2 input types\n   *\n   * @param transactionOrPayload AnyRawTransaction\n   * @param options asFeePayer. To sign a transaction as the fee payer sponsor\n   *\n   * @returns AptosSignTransactionOutput\n   */\n  async signTransaction(\n    transaction: AnyRawTransaction,\n    wallet: Wallet,\n    asFeePayer?: boolean\n  ): Promise<AptosSignTransactionOutput> {\n    const response = (await wallet.signTransaction!(\n      transaction,\n      asFeePayer\n    )) as UserResponse<AptosSignTransactionOutput>;\n    if (response.status === UserResponseStatus.REJECTED) {\n      throw new WalletConnectionError(\"User has rejected the request\").message;\n    }\n    return response.args;\n  }\n\n  /**\n   * Sign message\n   *\n   * @param message AptosSignMessageInput\n   * @return AptosSignMessageOutput\n   * @throws WalletSignMessageError\n   */\n  async signMessage(\n    message: AptosSignMessageInput,\n    wallet: Wallet\n  ): Promise<AptosSignMessageOutput> {\n    try {\n      const response = (await wallet.signMessage(\n        message\n      )) as UserResponse<AptosSignMessageOutput>;\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n      return response.args;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message AptosSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(\n    message: AptosSignMessageInput,\n    wallet: Wallet\n  ): Promise<boolean> {\n    try {\n      // sign the message\n      const response = (await wallet.signMessage(\n        message\n      )) as UserResponse<AptosSignMessageOutput>;\n      // standard wallet account() method is a required method\n      const account = (await wallet.account!()) as StandardAccountInfo;\n\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n\n      let verified = false;\n      // if is a multi sig wallet with a MultiEd25519Signature type\n      if (response.args.signature instanceof MultiEd25519Signature) {\n        if (!(account.publicKey instanceof MultiEd25519PublicKey)) {\n          throw new WalletSignMessageAndVerifyError(\n            \"Public key and Signature type mismatch\"\n          ).message;\n        }\n        const { fullMessage, signature } = response.args;\n        const bitmap = signature.bitmap;\n        if (bitmap) {\n          const minKeysRequired = account.publicKey.threshold;\n          if (signature.signatures.length < minKeysRequired) {\n            verified = false;\n          } else {\n            verified = account.publicKey.verifySignature({\n              message: new TextEncoder().encode(fullMessage),\n              signature,\n            });\n          }\n        }\n      } else {\n        verified = account.publicKey.verifySignature({\n          message: new TextEncoder().encode(response.args.fullMessage),\n          signature: response.args.signature,\n        });\n      }\n      return verified;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","export class GA4 {\n  readonly aptosGAID: string | undefined = process.env.GAID;\n\n  constructor() {\n    // Inject Aptos Google Analytics 4 script\n    this.injectGA(this.aptosGAID);\n  }\n\n  gtag(a: string, b: string | object, c?: object) {\n    let dataLayer = (window as any).dataLayer || [];\n    dataLayer.push(arguments);\n  }\n\n  private injectGA(gaID?: string) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n\n    const head = document.getElementsByTagName(\"head\")[0];\n\n    var myScript = document.createElement(\"script\");\n\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`\n    );\n\n    const that = this;\n    myScript.onload = function () {\n      that.gtag(\"js\", new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false,\n      });\n    };\n\n    head.insertBefore(myScript, head.children[1]);\n  }\n}\n","import { WalletName } from \"../LegacyWalletPlugins/types\";\nimport { WalletReadyState } from \"../constants\";\nimport { AptosStandardSupportedWallet } from \"./types\";\n\n/**\n * Registry of AIP-62 wallet standard supported wallets.\n * This list is used to show supported wallets even if they are not installed on the user machine.\n *\n * AIP-62 compatible wallets are required to add their wallet info here if they want to be detected by the adapter\n *\n * name - The wallet name\n * url - The wallet website url (where users can download it from)\n * icon - The wallet icon\n */\nexport const aptosStandardSupportedWalletList: Array<AptosStandardSupportedWallet> =\n  [\n    {\n      name: \"Nightly\" as WalletName<\"Nightly\">,\n      url: \"https://chromewebstore.google.com/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n    },\n    {\n      name: \"Petra\" as WalletName<\"Petra\">,\n      url: \"https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en\",\n      icon: \"data:image/png;base64,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\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n    },\n  ];\n","import { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\n\nexport { WalletCore } from \"./WalletCore\";\nexport * from \"./LegacyWalletPlugins\";\nexport * from \"./constants\";\nexport * from \"./utils\";\nexport * from \"./AIP62StandardWallets\";\n\nif (typeof window !== \"undefined\") {\n  (window as any).WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\n"],"mappings":"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","names":["TxnBuilderTypes","BCS","Network","AptosConfig","Aptos","EventEmitter","UserResponseStatus","WalletReadyState","NetworkName","generateTransactionPayload","AptosConfig","Network","AptosConfig","Network","generateTransactionPayload","oldTransactionPayload","TxnBuilderTypes","Types","EventEmitter","aptosWallets","AptosConfig","Aptos","UserResponseStatus","BCS","TxnBuilderTypes","Network"]}